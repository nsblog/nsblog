---
layout: post
title: "Garbage collector"
date: 2019-11-30 21:00:00 +0300
categories: jvm
permalink: garbage-collector
---

# Сбор мусора (`Garbage collector`) в `JVM HotSpot `

Сборщик мусора (``Garbage collector - GC`) - это инструмент управления памятью, который

- **выделяет память** для новых объектов и помещает их в `young generation`,
- **перемещает живые объекты** в `old generation`,
- **ищет живые объекты** в `generations`, используя параллельные стратегии маркировки,
- **восстанавливает память**, удаляя и сжимая объекты, используя параллельное копирование.



# Теория сборки мусора

## Закон Амдала и потеря пропускной способности

Закон Амдала (ускорение с помощью параллельного вычисления ограничено размером последовательной части программы) подразумевает что часть рабочих нагрузок не может быть распараллелена и выполняется всегда последовательно (работы при сборке мусора).

Математическое выражение закона Амдала, выглядит следующим образом, где

- `Sp` - возможно ускорение в количество раз,
- `a` - непараллезируемая часть работ, 
- `p` - количество процессоров.

![S_{p}={\cfrac  {1}{\alpha +{\cfrac  {1-\alpha }{p}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3d6be545af375c8517c584f7d0364b75892979a3)

Например, в идельной системе (`a` = 0) ускорение пропроционально количеству процессоров, например при `p` = 32, ускорение будет в 32 раза.

Если сборка мусора занимает 1% времени на однопроцессорной машине. То это приведет к потери пропускной способности более чем на 20% (23,6%) на 32ух процессорах.

Если сборка мусора занимает 10% времени (что не считается очень большим значением для однопроцессорных систем), то это приведет к более чем 75% (75,6%) потери пропускной способности на 32ух процессорах.

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

То есть незначительные проблемы пропускной способности, могут привести к большим проблемам (`bottleneck`) при масштабировании. С другой стороны, небольшие улучшения могут дать большой скачок в производительности. Поэтому для больших систем, целесообразно выбрать правильных `GC` и настроить его.



## Что такое мусор?

Объект считается мусором, когда на него нет ссылок в работающей программе.



## Наивный алгоритм

Оставить все объекты, которые доступны из работающей программы. Все остальные объекты удалить, так как это мусор.

### Неприемлемая производительность

Время работы алгоритма пропорционально количеству живых объектов, что неприемлемо для больших приложений, поддерживающих большое количество живых объектов.

### Как сделать производительность приемлемой?

В `JVM HotSpot` используются различные алгоритмы, но базовый принцип основан на гипотезе слабого поколения (`weak generational hypothesis`).



## Гипотеза слабого поколения (`Weak generational hypothesis`)

Гипотеза слабого поколения (`Weak generational hypothesis`) гласит "большинство объектов умрут молодыми".

Голубая область показывает типичное распределение времени жизни объектов.

- Ось X - это время жизни объекта, измеренное в байтах. 
- Ось Y - это общее количество байтов для объектов с соответствующим временем жизни.



![Типичное распределение времени жизни объектов](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_003_alc_vs_srvng.png)

- Острый пик слева представляет объекты, которые «умерли» вскоре после распределения. Например, объекты-итераторы часто работают в течение одного цикла.
- Некоторые объекты живут дольше, и поэтому распределение простирается вправо. Обычно объекты, выделенные при инициализации живут до завершения процесса.
- Между этими двумя крайностями находятся объекты, которые живут в течение некоторого промежуточного вычисления, рассматриваемого здесь как холм справа от левого пика.

> Некоторые приложения имеют другие формы распределения, но удивительно, что большинство обладает этой общей формой.

### Производительность

Время сбора мусора также пропорциональна количеству живых объектов. Однако так как области в `young generation` небольшие и полны мертвых объектов, то сбор мусора выполняется очень быстро. То есть эффективный сбор мусора возможен благодаря тому, что большинство объектов «умирают молодыми».

Как правило, некоторая часть выживших объектов из `young generation` перемещается в `ternted generarion` и так формируется основная куча. Сбор мусора в которой происходит дольше, так как объектов больше.



## Поколения (`Generations `)

В `JVM HotSpot` память разделяется на пулы, содержащие объекты разного возраста. Такие пулы называются "поколениями" (`generations`, `generational collection`).

Вся память `JVM` разделена на

- молодое поколение `young generation`, содержит
  - `Eden`,
  - `Survivor` (2е области), 
  - `Virtual`;
- штатное поколение `tenured geneartion`, содержит
  - основная куча,
  - `Virtual`.

>  Штатное поколение можно называть также старым (`old generation`).

**Схема поколений, за исключением `Parallel collector` и `G1`**

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_001_armgnt_gn.png)

`Virtual` - область, которая резервируется при инициализации, но память не выделяется физически.



### Как объекты двигаются по поколениям?

- Когда поколение заполняется, сборка мусора происходит только в нем; мусор в других поколениях не собирается.

- Большинство объектов изначально располагаются в `Eden`.

- Одно пространство `Survivor` всегда пустое. Другое служит для хранения выживших объектов из `Eden`. Если `Survivor` заполняется, то живые объекты копируются в пустой `Survivor`, а заполненный отчищается.

- Таким образом, объекты копируются между `Survivor` до тех пор, пока не станут достаточно взрослыми, чтобы их можно было переместить `tenured generation`.

  





# Настройка `GC`

## Эргономика

Эргономика - это процесс настройки `JVM` и `GC` с целью использовать оптимальный режим работы:

- повысить пропускную способность,
- уменьшить время пауз (отклика),
- уменьшить количество используемых ресурсов.



## Дефолтный выбор

`JVM` предоставляет платформо-зависимый автоматический выбор:

- сборщика мусора (`GC`),
- размера `heap`,
- компилятора времени выполения (`runtime compiler`).

Дефолтный выбор соответствует нуждам различных приложений и требует минимальной настройки через командную строку.

Для автоматического выбора значений `JVM` оперделяет операционную систему и параметры машины.

### Класс "Сервер" (`Server-class machine`) 

**TODO only 32-bit**

Машина определяется в класс `Server-class machine`, если имеет

- 2 или более физических процессоров,
- 2 или болee GB оперативной памяти.

Для `Server-class machine` по дефолту выбирается:

- `Throughput garbage collector`,
- Начальных хип (`Min heap`) = 1/64 оперативной памяти до 1GB,
- Максимальный хип (`Max heap`)  = 1/4 оперативной памяти до 1GB,
- Серверный компилятор времени выполнения (`Server runtime compiler`)





## Настройка на основе поведения (`Behavior-Based Tuning`)

Эргономика `JVM` предоставляет возможность автоматической динамической настройки `JMV` и `GC` на основе поведения приложения (`behavior-based tuning`). 



В добавок, настройка на основе поведения (`behavior-based tuning`) динамически настраивает размер `Heap` под приложение.



Используйте дефолтные настройки прежде чем использовать более детальные настройки.



# Behavior-Based Tuning

`Java SE` два параметра настройки сборки мусора, которые основаны на достижении определенного поведения приложения: 

- цель максимального времени паузы,
- цель пропускной способности приложения.

Эти два параметра недоступны в других сборщиках. Обратите внимание, что такое поведение не всегда может быть достижимо. Приложению требуется куча, достаточно большая, чтобы хотя бы хранить все оперативные данные. Кроме того, минимальный размер кучи может помешать достижению этих желаемых целей.



## Цель, максимальное время паузы

Время паузы - это продолжительность, в течение которой сборщик мусора останавливает приложение и восстанавливает пространство, которое больше не используется. Цель максимального времени паузы состоит в том, чтобы ограничить самый длинный из этих пауз. Среднее время для пауз и дисперсии в среднем поддерживается сборщиком мусора. Среднее значение берется с начала выполнения, но взвешивается таким образом, чтобы более поздние паузы учитывались в большей степени. Если среднее значение плюс дисперсия времени паузы превышает максимальное значение времени паузы, то сборщик мусора считает, что цель не достигнута.

Максимальное время паузы указывается с помощью параметра командной строки `XX:MaxGCPauseMillis=<nnn>`. Это интерпретируется как подсказка сборщику мусора о желаемом времени паузы `<nnn>` миллисекунд. Сборщик мусора будет корректировать размер кучи Java и другие параметры, связанные со сборкой мусора, чтобы сделать паузы сбора мусора короче, чем `<nnn>` миллисекунд. По умолчанию нет максимальной цели времени паузы. Эти корректировки могут привести к более частому запуску сборщика мусора, что приведет к снижению общей пропускной способности приложения. Сборщик мусора пытается достичь цели времени паузы, а после цели пропускной способности. В некоторых случаях, однако, желаемая цель времени паузы не может быть достигнута.



## Цель, максимальная пропускная способность

Цель пропускной способности измеряется с точки зрения времени, затраченного на сбор мусора, и времени, потраченного за пределами сбора мусора (называемого временем приложения). Цель задается параметром командной строки `-XX: GCTimeRatio = <nnn>`. Отношение времени сборки мусора к времени приложения составляет `1 / (1 + <nnn>)`. Например, `-XX: GCTimeRatio = 19` устанавливает цель в `1/20` или 5% от общего времени для сбора мусора.

Время, затрачиваемое на сборку мусора - это общее время для сборок как молодого, так и старого поколений. Если цель пропускной способности не достигается, размеры поколений увеличиваются, чтобы увеличить время, в течение которого приложение может выполняться между коллекциями



## Цель, отпечаток

Если были достигнуты цели пропускной способности и максимального времени паузы, то сборщик мусора уменьшает размер кучи до тех пор, пока не будет достигнута одна из целей (без исключения цели пропускной способности). Цель, которая не достигнута, затем решается.



# Стратегия настройки (`Tuning Strategy`)

Не выбирайте максимальное значение для кучи, если вы не знаете, что вам нужна куча, превышающая максимальный размер кучи по умолчанию. Выберите целевую пропускную способность, достаточную для вашего приложения.

Куча будет расти или уменьшаться до размера, который будет поддерживать выбранную цель пропускной способности. Изменение в поведении приложения может привести к увеличению или уменьшению кучи. Например, если приложение начинает выделять с более высокой скоростью, куча будет расти, чтобы поддерживать ту же пропускную способность.

Если размер кучи увеличивается до максимального размера, а цель пропускной способности не достигается, максимальный размер кучи слишком мал для цели пропускной способности. Установите для максимального размера кучи значение, близкое к общему объему физической памяти на платформе, но не вызывающее перестановки приложения. Запустите приложение еще раз. Если цель по пропускной способности все еще не достигнута, тогда цель для времени приложения слишком высока для доступной памяти на платформе.

Если цель пропускной способности может быть достигнута, но есть паузы, которые являются слишком длинными, то выберите максимальную цель времени паузы. Выбор цели максимального времени паузы может означать, что ваша цель по пропускной способности не будет достигнута, поэтому выберите значения, которые являются приемлемым компромиссом для приложения.

Типично, что размер кучи будет колебаться, поскольку сборщик мусора пытается удовлетворить конкурирующие цели. Это верно, даже если приложение достигло устойчивого состояния. Давление для достижения цели по пропускной способности (которая может потребовать большей кучи) конкурирует с целями за максимальное время паузы и минимальную занимаемую площадь (что может потребовать небольшой кучи).





# Вопросы производительности

Существует два основных показателя производительности сборки мусора:

- Пропускная способность (`Throughput`) - это процент времени работы приложения, не включая время на сборку мусора, к общему времени.

  > Пропускная способность включает время, затраченное на выделение памяти для создания объектов (`allocation`) (но настройка скорости создания объектов обычно не требуется).

- Паузы - это время, когда приложение перестает отвечать на запросы, поскольку происходит сборка мусора.



# Требования пользователей

У пользователей разные требования к сборке мусора:

- Пропускная способность (`Throughput`)
  - Часто для веб-сервера пропусканая спосбоность наиболее важная метрика, так как паузы во время сборки мусора могут быть терпимы или просто скрыты сетевыми задержками.
- Паузы (`Pause`)
  - Для интерактивной графической программе даже короткие паузы могут отрицательно влиять на работу с приложением.
- Ресурсопотребление (`Footprint`)
  - В системах с ограниченной физической памятью или множеством других процессов, ресурсопотребление может определять масштабируемость.
- Оперативность (`Promptness`)
  - Оперативность (`Promptness`) - это время между тем, когда объект становится мертвым, и когда память становится доступной, что является важным фактором для распределенных систем, включая RMI.

Так как требования у пользователей разные, то и не существует единственного правильного способа как настроить размер поколений. В целом, выбор размера поколений является компромиссом между этими требованиями. 

Например, очень большое `young generation` может максимизировать пропускную способность (`Throughput`), но делает это за счет `Footprint, Promptness` и `Pause`. Паузы `young generation` могут быть минимизированы с помощью небольшого размера `young generation`  за счет пропускной способности (`Throughput`). 



# Измерение

- Пропускная способность (`Throughput`)
  - Пропускная способность веб-сервера может быть проверена с помощью клиента генератора нагрузки.
- Ресурсопотребление (`Footprint`)
  - Ресурсопотребление может быть измерено в операционной системе `Solaris` с помощью команды `pmap`.
- Паузы (`Pause`)
  - Паузы из-за сборки мусора легко оценить с помощью диагностического вывода самой `JVM`.



Команда `-verbose: gc` заставляет печатать информацию о куче и сборке мусора в каждой коллекции, например:

```bash
[GC 325407K->83000K(776768K), 0.2300771 secs]
[GC 325816K->83372K(776768K), 0.2454258 secs]
[Full GC 267628K->83769K(776768K), 1.8479984 secs]
```

Выходные данные показывают две `minor collections`, за которыми следует одна `major collection`. Числа до и после стрелки, например, `325407K-> 83000K`, указывают размер живых объектов до и после сборки мусора, соответственно. 



После `minor collections` ???

Размер включает некоторые объекты, которые являются мусором (больше не живы), но не могут быть удалены. Эти объекты либо содержатся в `tenured generation`, либо ссылаются на `tenured generation`.

After minor collections, the size includes some objects that are garbage (no longer alive) but cannot be reclaimed. These objects are either contained in the tenured generation or referenced from the tenured generation.



Число в скобках, например `(776768K)`- это размер выделленой памяти в `heap`. 

Обратите внимание, что это число включает только одно областей `Survivor`. 

За исключением случаев сбора мусора, в любой момент времени для хранения объектов будет использоваться только одно `Survivor`.

Время `0.2300771 secs`  показывает за сколько была обработана коллекция.



## Команда `-XX:+PrintGCDetails`

Команда `-XX: + PrintGCDetails` выводит дополнительную информацию:

```bash
[GC [DefNew: 64575K->959K(64576K), 0.0457646 secs] 196016K->133633K(261184K), 0.0459067 secs]
```

- Цифры `DefNew: 64575K-> 959K (64576K)` показываеют, что `minor collection` восстановила около 98% памяти и заняло `0,0457646 secs`.
- Цифры `196016K-> 133633K (261184K)` показывают как сборка мусора повлияла на общий размере `heap`'а, то есть стало доступно ~50% памяти. Общее время `0,0459067 secs` включает время восстановления `minor collection` + дополнительные расходы.



## Команда `-XX:+PrintGCTimeStamps `

Команда `-XX:+PrintGCTimeStamps` добавляет `timestamp` начала сборки мусора, используется для того, чтобы узнать как часто запускается `GC`.

```bash
111.042: [GC 111.042: [DefNew: 8128K->8128K(8128K), 0.0000505 secs]111.042: [Tenured: 18154K->2311K(24576K), 0.1290354 secs] 26282K->2311K(32704K), 0.1293306 secs]
```

- Цифры `111.042` означают, что сборка мусора началась через 111 секунд после старта приложения.
- Вторая цифра `111.042` означает, что сборка `minor collection` началась в то же время.
- Также вывелась информация о `Tenured collection`.





# Доступные сборщики

`JVM HotSpot` включает в себя три различных сборщика мусора:

- Последовательный сборщик (`The serial collector`) .

  - Использует один поток для выполнения всей работы по сбору мусора, что делает его относительно эффективным, потому что нет никаких коммуникационных издержек между потоками. 
  - Лучше всего подходит для однопроцессорных машин, но также может быть полезен на многопроцессорных системах c размером `heap` примерно до 100 МБ.
  - Включается с помощью команды `-XX: +UseSerialGC`.

- Параллельный сборщик (`The parallel collector or the throughput collector`)

  - Работает также как последовательный, но для сборки мусора использует несколько потоков.
  - Предназначен для приложений с наборами данных среднего и большого размера, которые работают на многопроцессорном или многопоточном оборудовании. 
  - Включается с помощью команды `-XX: +UseParallelGC`.
  - `Parallel compaction` - это опция, которая включает параллельную сборку мусора в `major collection`. Без этой опции сборка мусора для `major collection` будет использовать один поток.
  - По умолчанию включена, если включена `-XX:+UseParallelGC`.
  - Может быть выключена с помощью `-XX:-UseParallelOldGC`.

- Максимально параллельные сборщики (`The mostly concurrent collector`)

  - Выполняют большинство работы параллельно, то есть даже когда работает приложение, чтобы обеспечить минимальные паузы при сборке мусора.
  - ` JVM HotSpot ` предлагает два сборщика: `CMS` и `G1`.
  - Сборщики предназначены для приложений со средним и большим размером `heap` в которых время отклика важнее, чем общая пропускная способность, та как методы, используемые для минимизации пауз, могут снизить производительность приложений.
  - Используйте параметр `-XX: +UseConcMarkSweepGC` для включения сборщика `CMS` или `-XX: +UseG1GC` для включения сборщика `G1`.

  



## Выбор сборщика мусора

Если ваше приложение не предъявляет достаточно строгих требований к времени паузы, сначала запустите ваше приложение и позвольте виртуальной машине выбрать коллектор. При необходимости отрегулируйте размер кучи для повышения производительности. Если производительность по-прежнему не соответствует вашим целям, используйте следующие рекомендации в качестве отправной точки для выбора коллектора.

- Если приложение имеет небольшой набор данных (примерно до 100 МБ), то выберите последовательный коллектор с опцией -XX: + UseSerialGC.
- Если приложение будет запущено на одном процессоре и нет требований к времени паузы, тогда позвольте виртуальной машине выбрать коллектор или выбрать последовательный коллектор с опцией -XX: + UseSerialGC.
- Если (а) пиковая производительность приложения является первым приоритетом и (б) нет требований к времени паузы или допустимы паузы в 1 секунду или более, тогда позвольте виртуальной машине выбрать коллектор или выбрать параллельный коллектор с помощью -XX: + UseParallelGC.
- Если время отклика важнее, чем общая пропускная способность, и паузы при сборке мусора должны быть короче, чем приблизительно 1 секунда, выберите параллельный сборщик с -XX: + UseConcMarkSweepGC или -XX: + UseG1GC.



Эти рекомендации предоставляют только отправную точку для выбора сборщика мусора, поскольку производительность зависит 

- от размера кучи (`heap`), 
- количества живых объектов в приложении и 
- числа и производительности используемых процессоров.

Время паузы особенно чувствительно к этим факторам, поэтому упомянутый ранее порог в 1 секунду является лишь приблизительным: 

параллельный коллектор (` the parallel collector`) будет иметь длительность паузы, превышающую 1 секунду, для многих комбинаций размера кучи и оборудования; 

и наоборот, параллельный коллектор (`the concurrent collector`) может не поддерживать паузы короче 1 секунды в некоторых комбинациях.

Если рекомендуемый сборщик не достигает желаемой производительности, сначала попытайтесь отрегулировать кучу и размеры `minor and major collections`. 

Если производительность по-прежнему недостаточна, попробуйте другой сборщик: используйте параллельный сборщик (`the concurrent collector`), чтобы уменьшить время паузы, и используйте параллельный сборщик (`the parallel collector`), чтобы увеличить общую пропускную способность на многопроцессорном оборудовании.





# Последовательный сборщик (`Serial collector`)

Последовательный сборщик (`Serial collector`) обычно подходит для небольших приложений на однопроцессорных машинах с размером `heap` примерно до 100MB. 

**TODO**

Использование параллельных коллекторов не рекомендуется в таких условиях, так как они имеют дополнительные накладные расходы и сложность, что является ценой за специализированное поведени.





# Параллельный сборщик (`The Parallel Collector` or `The Throughput Collector`)

Параллельный сборщик (`The Parallel Collector` or `The Throughput Collector`) работает также как и последовательный сборщик, основное отличие в том, что для ускорения сбора мусора используется несколько потоков.

Параллельный сборщик включается так:

```bash
java -XX:+UseParallelGC -Xmx2g -Xms32m -jar app.jar 10
```

По умолчанию, при использовании этой опции, сборка мусора выполняется параллельно во всех поколениях.

- Параллельный сборщик выбран по умолчанию на машинах серверного класса.



## Сколько ядер используется?

- На машинах с 8 ядрами и более, параллельный сборщик использует 5/8 ресурсов,
- на машинах с менее 8 ядрами, доля уменьшается до 5/16,
- можно настроить конкретное число потоков с помощью команды`-XX: ParallelGCThreads = <N>`.



## Параллельный сборщик VS Последовательный сборщик

- **Ядер = 1**. На машине с одним ядром параллельный сборщик, не будет работать также хорошо как и последовательный сборщик, из-за накладных расходов (синхронизации и тд).

- **Ядер = 2**. На двух ядрах параллельный сборщик обычно превосходит последовательный на скромную велечину.

- **Ядер > 2**. Кода доступно более двух ядер паралелльный сборщик обычно значительно лучше, чем последовательный.

  

## Эффект фрагментации

- Для обеспечения хорошей производительности при использовании последовательного или параллельного сборщика **размер `Heap`'а не отличается**.

- Включение параллельного сборщика должно сделать паузы сбора короче.

- А также при использовании параллельного-сборщика может наблюдаться эффект фрагментации. Когда несколько потоков обрабатывают `young generation` и передвигают объекты в `tenured generation`, потоки резервируют части памяти (`"promotion buffers"`) в `ternured generation`, данный процесс может стать причиной фрагментации. 

  - Уменьшение количества потоков сборки мусора и увеличение размера `tenured generation` уменьшит эффект фрагментации.

  

## Поколения (`Generations`)

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_002_armgnt_gn_pl.png)



## Эргономика параллельного сборщика (`Parallel Collector Ergonomics`)

- Кроме того, в параллельном коллекторе используется метод автоматической настройки, который позовляет выбирать специализированное поведение, вместо низко-уровневной настройки.
- Вы можете указать максимальное время приостановки сбора мусора, пропускную способность и площадь (размер кучи).
- **Максимальная пауза GC**
  - По умолчанию нет максимальной времени паузы,
  - чтобы указать, используется команда `-XX:MaxGCPauseMillis=<N>`.
  - Команда интерпретируется как подсказка, что желательное времени паузы должно быть меньше чем `N` милисекунд.
  - Если задана "максимальная пауза", тогда размер `heap` и другие параметра, коректируются, чтобы достичь цели. Эти корректировки могут привести к уменьшению общей пропускной способности приложения и желаемая цель также может быть не достигнута.
- **Пропускная способность (`Throughput`) **
  - Цель пропускной способности измеряется с точки зрения времени, потраченного на сборку мусора, по сравнению с временем, потраченным вне сбора мусора (называемое временем приложения).
  - Цель задается параметром командной строки `-XX: GCTimeRatio = <N>`, который устанавливает отношение времени сборки мусора к времени приложения в `1 / (1 + <N>)`.
- **Footprint**
  - Максимальный размер кучи указывается с помощью опции `-Xmx <N>`. Кроме того, сборщик имеет неявную цель минимизировать размер кучи, пока выполняются другие цели.



## Приоритеты целей

Цели решаются в следующем порядке:

- Максимальное время паузы
- Пропускная способность
- Минимальная цель следа

Максимальное время паузы достигается первым. Только после того, как это достигнуто, цель пропускной способности адресована. Точно так же, только после того, как первые две цели были достигнуты, рассматривается цель следа.



## Корректировка `Generations`

- Статистика средней времени паузы обновляется каждый раз после обработки каждой коллекций `generations`.
- Затем выполняются тесты для определения того, были ли достигнуты цели и вносятся необходимые корректировки в размер `generations`.
- Исключение, то есть статистика не собирается, при явных вызовах сборщика мусора (`Systems.gc()`).



## Увеличение и уменьшение размера `generations` 

- Увеличение и уменьшение размера `generation` измеряется в процентах от размера поколения.
- Рост и сжатие осуществляется с разными величинами.
- По умолчанию `generations` увеличивается на 20%, а уменьшается на 5%.
- Для `young generation` процесс роста задаётся командой `-XX: YoungGenerationSizeIncrement = <Y>`
- Для `turned generation` - `-XX: TenuredGenerationSizeIncrement = <T>`
- Процент сжатия настраивается командой `-XX: AdaptiveSizeDecrementScaleFactor = <D>`, если прирост составляет `X` процентов, то уменьшение при сокращении составляет `X/D` процентов.
- При запуске приложения может добавляться дополнительный процент к увеличения `generation`, этот эффект не долгосрочный. Целью является повышения производительности при запуске.
- Если максимальное время паузы не достигается, тогда размер только одного поколения `generation` сокращается за раз. Если время паузы обоих поколений выше цели, то размер поколения с большим временем паузы сокращается первым.
- Если цель пропускной способности не достигается, размеры обоих поколений увеличиваются. Каждое поколение увеличивается пропорционально вкладу в общее время сбора мусора.  Например, если время сбора мусора молодого поколения составляет 25% от общего времени сбора, и если полный прирост поколений будет на 20%, то молодое поколение будет увеличено на 5%.



## Дефолтный размер `Heap` для `Client JVM`

- Если не указан начальный и максимальный размеры кучи через командную строку, значения рассчитываются на основе объема памяти на машине.
- Максимальный размер кучи, равен
  - 1/2 физической памяти, если на машине до 192MB;
    - Если на машине 128MB, то максимальный размер - 64MB.
  - 1/4 физической памяти (но не больше 1GB), если на машине больше 192MB.
    - Если на машине 1GB, то максимальный размер - 256MB.
- Минимальный размер кучи (`initial heap size`), равен
  - минимум 8MB или 1/64 физической памяти (но не больше 1GB).
- Максимальный размер `young generation` = 1/3 `heap`.



## Дефолтный размер `Heap` для `Server JVM`

- На `32-bit JVMs` может достигать 1GB, если на машине 4GB или больше.
- На `64-bit JVMs` может достигать 32GB, если на машине 128GB или больше.



## Указать  начальный и максимальный размер `heap`

- `-Xms` -  (initial heap size)

- `-Xmx` - (maximum heap size)

- Если вы знаете какой размер `heap` нужен для вашего приложения, можете установить `-Xms` и `-Xmx` в одно и то же значение. Если нет, `JVM` запустится с использованием начального размера кучи, а затем будет увеличивать кучу, пока не найдет баланс между использованием кучи и производительностью.

- Для проверки дефолтных значений используйте команду `-XX:+PrintFlagsFinal` .

  ```bash
  java -XX:+PrintFlagsFinal <GC options> -version | grep MaxHeapSize
  ```

  

## Excessive GC Time and OutOfMemoryError

Параллельный сборщик выдает ошибку OutOfMemoryError, если слишком много времени тратится на сборку мусора (GC):

- Если на сборку мусора уходит более 98% общего времени и восстанавливается менее 2% кучи, то генерируется ошибка OutOfMemoryError
- Эта функция предназначена для предотвращения длительного периода работы при ничтожном прогрессе, поскольку куча слишком мала.
- При необходимости эту функцию можно отключить, добавив параметр `-XX: -UseGCOverheadLimit`.







## Максимально-параллельные сборщики мусора

`JVM Hotspot`имеет два максимально-параллельных сборщика мусора в `JDK 8`:

- `Concurrent Mark Sweep (CMS) Collector` - это коллектор предназначен для приложений, которые предпочитают более короткие паузы сбора мусора и могут позволить себе совместно использовать ресурсы процессора при сборке мусора.
- `Garbage-First Garbage Collector` - это серверный коллектор предназначен для многопроцессорных машин с большим объемом памяти. Он с высокой вероятностью отвечает целевым показателям времени паузы при достижении высокой пропускной способности.



## Накладные расходы параллелизма

`The mostly concurrent collector` тратит ресурсы процессора, (которые в противном случае были бы доступны приложению) для достижения более коротких пауз при сборке мусора в `major collecton`.

Наиболее заметные накладные расходы - это использование одного или нескольких процессоров во время параллельной части работы с коллекциями `collection.`

В N процессорной системе параллельная часть работ с `collection` будет использовать K / N доступных процессоров, где 1 <= K <= потолок {N / 4}. (Обратите внимание, что значение K предмет выбора.) 

В дополнение к использованию процессоров во время `concurrent phases`, дополнительные издержки возникают для обеспечения параллелизма.

Таким образом, хотя паузы при сборке мусора обычно намного короче с `the concurrent collector`, пропускная способность приложения также имеет тенденцию быть немного ниже, чем с другими сборщиками.

На машине с более чем одним ядром, процессоры доступны для работы приложения во время сборки мусора, поэтому, поэтому `the concurrent garbage collector` не «приостанавливает» приложение.

Обычно это приводит к более коротким паузам, но опять-таки приложению доступно меньше ресурсов процессора, и следует ожидать некоторого замедления, особенно если приложение максимально использует все ядра.

По мере увеличения числа процессоров `N`, нехватка ресурсов процесса становится меньше, а преимущество от использования одновременного сбора мусора увеличивается.

В разделе `Concurrent Mode Failure` в сборщике одновременной пометки (`CMS`) обсуждаются потенциальные ограничения для такого масштабирования.

Поскольку по крайней мере один процессор используется для сбора мусора во время параллельных фаз, `the concurrent collectors` обычно не дают никаких преимуществ на однопроцессорной (одноядерной) машине.

Однако для `CMS` доступен отдельный режим (не `G1`), который позволяет достигать низких пауз в системах с одним или двумя процессорами; подробности см. ` Incremental Mode in Concurrent Mark Sweep (CMS) Collector`.







# NOTES

1. Определение размера одного поколения не влияет на частоту сбора и время паузы для другого поколения.
2. The Java HotSpot VM triggers the marking phase when the total Java heap occupancy exceeds the default threshold. See the sections [Concurrent Mark Sweep (CMS) Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector) and [Garbage-First Garbage Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection).



# Вопросы

- Когда выбор `GC` имеет значение?
  - For some applications, the answer is never. That is, the application can perform well in the presence of garbage collection with pauses of modest frequency and duration. However, this is not the case for a large class of applications, particularly those with large amounts of data (multiple gigabytes), many threads, and high transaction rates.
- Как звучит закон Амдала?
  - Amdahl's law (parallel speedup in a given problem is limited by the sequential portion of the problem) implies that most workloads cannot be perfectly parallelized; some portion is always sequential and does not benefit from parallelism.
- Как влияет сборка мусора на потерю пропускной способности на малых и больших системах? И почему?
- "Если сборка мусора занимает 1% времени на однопроцессорной машине. То это приведет к 20% потери пропускной способности при 32 процессорах". Почему так происходит?
  - Связано с законом Амдала, то в идеальных условиях можно ускороить программу в n раз, где n - это количество процессоров. Но каждая задача имеет не параллезируюмую работы (сборка мусора), это снижает потенциальную пропускную способность.
- Когда стоит и не стоит использовать `Serial collector`?
- Когда `Serial collector` выбирается по умолчанию?
- Какой самый простой способ отчистить мусора?
- Почему он не подходит?
- На какой аксиопер построена сборка мусора с использованием поколений?
- Какой сборщик мусора работает по умолчанию?
- Чем различаются `generations` для разных `GC`?
- Сколько раз объекты копируются из `Survivor`?
- Как `GC` решает, что нужно кинуть `OutOfMemoryError`? 
- Можно ли отключить `OutOfMemoryError`?
- Можно ли динамически увеличить память после `OutOfMemoryError`?
- HotSpot VM Frequently Asked Questions (FAQ) -> https://www.oracle.com/technetwork/java/hotspotfaq-138619.html



# Источники

1. [Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)
2. [Java HotSpot Garbage Collection](https://www.oracle.com/technetwork/java/javase/tech/index-jsp-140228.html)
3. [Open JDK - Storage Management](http://openjdk.java.net/groups/hotspot/docs/StorageManagement.html)
4. Richard Jones and Rafael Lins, *Garbage Collection: Algorithms for Automated Dynamic Memory Management*, Wiley and Sons (1996), ISBN 0-471-94148-4

