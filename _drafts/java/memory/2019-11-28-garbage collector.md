---
layout: post
title: "Garbage collector"
date: 2019-11-30 21:00:00 +0300
categories: jvm
permalink: garbage-collector
---

# Сбор мусора (`Garbage collector`) в `JVM HotSpot `

Сборщик мусора (``Garbage collector - GC`) - это инструмент управления памятью, который

- **выделяет память** для новых объектов и помещает их в `young generation`,
- **перемещает живые объекты** в `old generation`,
- **ищет живые объекты** в `generations`, используя параллельные стратегии маркировки,
- **восстанавливает память**, удаляя и сжимая объекты, используя параллельное копирование.



# Теория сборки мусора

## Закон Амдала и потеря пропускной способности

Закон Амдала (ускорение с помощью параллельного вычисления ограничено размером последовательной части программы) подразумевает что часть рабочих нагрузок не может быть распараллелена и выполняется всегда последовательно (работы при сборке мусора).

Математическое выражение закона Амдала, выглядит следующим образом, где

- `Sp` - возможно ускорение в количество раз,
- `a` - непараллезируемая часть работ, 
- `p` - количество процессоров.

![S_{p}={\cfrac  {1}{\alpha +{\cfrac  {1-\alpha }{p}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3d6be545af375c8517c584f7d0364b75892979a3)

Например, в идельной системе (`a` = 0) ускорение пропроционально количеству процессоров, например при `p` = 32, ускорение будет в 32 раза.

Если сборка мусора занимает 1% времени на однопроцессорной машине. То это приведет к потери пропускной способности более чем на 20% (23,6%) на 32ух процессорах.

Если сборка мусора занимает 10% времени (что не считается очень большим значением для однопроцессорных систем), то это приведет к более чем 75% (75,6%) потери пропускной способности на 32ух процессорах.

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

То есть незначительные проблемы пропускной способности, могут привести к большим проблемам (`bottleneck`) при масштабировании. С другой стороны, небольшие улучшения могут дать большой скачок в производительности. Поэтому для больших систем, целесообразно выбрать правильных `GC` и настроить его.



## Что такое мусор?

Объект считается мусором, когда на него нет ссылок в работающей программе.



## Наивный алгоритм

Оставить все объекты, которые доступны из работающей программы. Все остальные объекты удалить, так как это мусор.

### Неприемлемая производительность

Время работы алгоритма пропорционально количеству живых объектов, что неприемлемо для больших приложений, поддерживающих большое количество живых объектов.

### Как сделать производительность приемлемой?

В `JVM HotSpot` используются различные алгоритмы, но базовый принцип основан на гипотезе слабого поколения (`weak generational hypothesis`).



## Гипотеза слабого поколения (`Weak generational hypothesis`)

Гипотеза слабого поколения (`Weak generational hypothesis`) гласит "большинство объектов умрут молодыми".

Голубая область показывает типичное распределение времени жизни объектов.

- Ось X - это время жизни объекта, измеренное в байтах. 
- Ось Y - это общее количество байтов для объектов с соответствующим временем жизни.



![Типичное распределение времени жизни объектов](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_003_alc_vs_srvng.png)

- Острый пик слева представляет объекты, которые «умерли» вскоре после распределения. Например, объекты-итераторы часто работают в течение одного цикла.
- Некоторые объекты живут дольше, и поэтому распределение простирается вправо. Обычно объекты, выделенные при инициализации живут до завершения процесса.
- Между этими двумя крайностями находятся объекты, которые живут в течение некоторого промежуточного вычисления, рассматриваемого здесь как холм справа от левого пика.

> Некоторые приложения имеют другие формы распределения, но удивительно, что большинство обладает этой общей формой.

### Производительность

Время сбора мусора также пропорциональна количеству живых объектов. Однако так как области в `young generation` небольшие и полны мертвых объектов, то сбор мусора выполняется очень быстро. То есть эффективный сбор мусора возможен благодаря тому, что большинство объектов «умирают молодыми».

Как правило, некоторая часть выживших объектов из `young generation` перемещается в `ternted generarion` и так формируется основная куча. Сбор мусора в которой происходит дольше, так как объектов больше.



## Поколения (`Generations `)

В `JVM HotSpot` память разделяется на пулы, содержащие объекты разного возраста. Такие пулы называются "поколениями" (`generations`, `generational collection`).

Вся память `JVM` разделена на

- молодое поколение `young generation`, содержит
  - `Eden`,
  - `Survivor` (2е области), 
  - `Virtual`;
- штатное поколение `tenured geneartion`, содержит
  - основная куча,
  - `Virtual`.

>  Штатное поколение можно называть также старым (`old generation`).

**Схема поколений, за исключением `Parallel collector` и `G1`**

![](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_001_armgnt_gn.png)

`Virtual` - область, которая резервируется при инициализации, но память не выделяется физически.



### Как объекты двигаются по поколениям?

- Когда поколение заполняется, сборка мусора происходит только в нем; мусор в других поколениях не собирается.

- Большинство объектов изначально располагаются в `Eden`.

- Одно пространство `Survivor` всегда пустое. Другое служит для хранения выживших объектов из `Eden`. Если `Survivor` заполняется, то живые объекты копируются в пустой `Survivor`, а заполненный отчищается.

- Таким образом, объекты копируются между `Survivor` до тех пор, пока не станут достаточно взрослыми, чтобы их можно было переместить `tenured generation`.

  





# Настройка `GC`

## Эргономика

Эргономика - это процесс настройки `JVM` и `GC` с целью использовать оптимальный режим работы:

- повысить пропускную способность,
- уменьшить время пауз (отклика),
- уменьшить количество используемых ресурсов.



## Дефолтный выбор

`JVM` предоставляет платформо-зависимый автоматический выбор:

- сборщика мусора (`GC`),
- размера `heap`,
- компилятора времени выполения (`runtime compiler`).

Дефолтный выбор соответствует нуждам различных приложений и требует минимальной настройки через командную строку.

Для автоматического выбора значений `JVM` оперделяет операционную систему и параметры машины.

### Класс "Сервер" (`Server-class machine`) 

**TODO only 32-bit**

Машина определяется в класс `Server-class machine`, если имеет

- 2 или более физических процессоров,
- 2 или болee GB оперативной памяти.

Для `Server-class machine` по дефолту выбирается:

- `Throughput garbage collector`,
- Начальных хип (`Min heap`) = 1/64 оперативной памяти до 1GB,
- Максимальный хип (`Max heap`)  = 1/4 оперативной памяти до 1GB,
- Серверный компилятор времени выполнения (`Server runtime compiler`)





## Настройка на основе поведения (`Behavior-Based Tuning`)

Эргономика `JVM` предоставляет возможность автоматической динамической настройки `JMV` и `GC` на основе поведения приложения (`behavior-based tuning`). 



В добавок, настройка на основе поведения (`behavior-based tuning`) динамически настраивает размер `Heap` под приложение.



Используйте дефолтные настройки прежде чем использовать более детальные настройки.



# Behavior-Based Tuning

`Java SE` два параметра настройки сборки мусора, которые основаны на достижении определенного поведения приложения: 

- цель максимального времени паузы,
- цель пропускной способности приложения.

Эти два параметра недоступны в других сборщиках. Обратите внимание, что такое поведение не всегда может быть достижимо. Приложению требуется куча, достаточно большая, чтобы хотя бы хранить все оперативные данные. Кроме того, минимальный размер кучи может помешать достижению этих желаемых целей.



## Цель, максимальное время паузы

Время паузы - это продолжительность, в течение которой сборщик мусора останавливает приложение и восстанавливает пространство, которое больше не используется. Цель максимального времени паузы состоит в том, чтобы ограничить самый длинный из этих пауз. Среднее время для пауз и дисперсии в среднем поддерживается сборщиком мусора. Среднее значение берется с начала выполнения, но взвешивается таким образом, чтобы более поздние паузы учитывались в большей степени. Если среднее значение плюс дисперсия времени паузы превышает максимальное значение времени паузы, то сборщик мусора считает, что цель не достигнута.

Максимальное время паузы указывается с помощью параметра командной строки `XX:MaxGCPauseMillis=<nnn>`. Это интерпретируется как подсказка сборщику мусора о желаемом времени паузы `<nnn>` миллисекунд. Сборщик мусора будет корректировать размер кучи Java и другие параметры, связанные со сборкой мусора, чтобы сделать паузы сбора мусора короче, чем `<nnn>` миллисекунд. По умолчанию нет максимальной цели времени паузы. Эти корректировки могут привести к более частому запуску сборщика мусора, что приведет к снижению общей пропускной способности приложения. Сборщик мусора пытается достичь цели времени паузы, а после цели пропускной способности. В некоторых случаях, однако, желаемая цель времени паузы не может быть достигнута.



## Цель, максимальная пропускная способность

Цель пропускной способности измеряется с точки зрения времени, затраченного на сбор мусора, и времени, потраченного за пределами сбора мусора (называемого временем приложения). Цель задается параметром командной строки `-XX: GCTimeRatio = <nnn>`. Отношение времени сборки мусора к времени приложения составляет `1 / (1 + <nnn>)`. Например, `-XX: GCTimeRatio = 19` устанавливает цель в `1/20` или 5% от общего времени для сбора мусора.

Время, затрачиваемое на сборку мусора - это общее время для сборок как молодого, так и старого поколений. Если цель пропускной способности не достигается, размеры поколений увеличиваются, чтобы увеличить время, в течение которого приложение может выполняться между коллекциями



## Цель, отпечаток

Если были достигнуты цели пропускной способности и максимального времени паузы, то сборщик мусора уменьшает размер кучи до тех пор, пока не будет достигнута одна из целей (без исключения цели пропускной способности). Цель, которая не достигнута, затем решается.



# Стратегия настройки (`Tuning Strategy`)

Не выбирайте максимальное значение для кучи, если вы не знаете, что вам нужна куча, превышающая максимальный размер кучи по умолчанию. Выберите целевую пропускную способность, достаточную для вашего приложения.

Куча будет расти или уменьшаться до размера, который будет поддерживать выбранную цель пропускной способности. Изменение в поведении приложения может привести к увеличению или уменьшению кучи. Например, если приложение начинает выделять с более высокой скоростью, куча будет расти, чтобы поддерживать ту же пропускную способность.

Если размер кучи увеличивается до максимального размера, а цель пропускной способности не достигается, максимальный размер кучи слишком мал для цели пропускной способности. Установите для максимального размера кучи значение, близкое к общему объему физической памяти на платформе, но не вызывающее перестановки приложения. Запустите приложение еще раз. Если цель по пропускной способности все еще не достигнута, тогда цель для времени приложения слишком высока для доступной памяти на платформе.

Если цель пропускной способности может быть достигнута, но есть паузы, которые являются слишком длинными, то выберите максимальную цель времени паузы. Выбор цели максимального времени паузы может означать, что ваша цель по пропускной способности не будет достигнута, поэтому выберите значения, которые являются приемлемым компромиссом для приложения.

Типично, что размер кучи будет колебаться, поскольку сборщик мусора пытается удовлетворить конкурирующие цели. Это верно, даже если приложение достигло устойчивого состояния. Давление для достижения цели по пропускной способности (которая может потребовать большей кучи) конкурирует с целями за максимальное время паузы и минимальную занимаемую площадь (что может потребовать небольшой кучи).





# Вопросы производительности

Существует два основных показателя производительности сборки мусора:

- Пропускная способность (`Throughput`) - это процент времени работы приложения, не включая время на сборку мусора, к общему времени.

  > Пропускная способность включает время, затраченное на выделение памяти для создания объектов (`allocation`) (но настройка скорости создания объектов обычно не требуется).

- Паузы - это время, когда приложение перестает отвечать на запросы, поскольку происходит сборка мусора.



# Требования пользователей

У пользователей разные требования к сборке мусора:

- Пропускная способность (`Throughput`)
  - Часто для веб-сервера пропусканая спосбоность наиболее важная метрика, так как паузы во время сборки мусора могут быть терпимы или просто скрыты сетевыми задержками.
- Паузы (`Pause`)
  - Для интерактивной графической программе даже короткие паузы могут отрицательно влиять на работу с приложением.
- Ресурсопотребление (`Footprint`)
  - В системах с ограниченной физической памятью или множеством других процессов, ресурсопотребление может определять масштабируемость.
- Оперативность (`Promptness`)
  - Оперативность (`Promptness`) - это время между тем, когда объект становится мертвым, и когда память становится доступной, что является важным фактором для распределенных систем, включая RMI.

Так как требования у пользователей разные, то и не существует единственного правильного способа как настроить размер поколений. В целом, выбор размера поколений является компромиссом между этими требованиями. 

Например, очень большое `young generation` может максимизировать пропускную способность (`Throughput`), но делает это за счет `Footprint, Promptness` и `Pause`. Паузы `young generation` могут быть минимизированы с помощью небольшого размера `young generation`  за счет пропускной способности (`Throughput`). 



# Измерение

- Пропускная способность (`Throughput`)
  - Пропускная способность веб-сервера может быть проверена с помощью клиента генератора нагрузки.
- Ресурсопотребление (`Footprint`)
  - Ресурсопотребление может быть измерено в операционной системе `Solaris` с помощью команды `pmap`.
- Паузы (`Pause`)
  - Паузы из-за сборки мусора легко оценить с помощью диагностического вывода самой `JVM`.



Команда `-verbose: gc` заставляет печатать информацию о куче и сборке мусора в каждой коллекции, например:

```bash
[GC 325407K->83000K(776768K), 0.2300771 secs]
[GC 325816K->83372K(776768K), 0.2454258 secs]
[Full GC 267628K->83769K(776768K), 1.8479984 secs]
```

Выходные данные показывают две `minor collections`, за которыми следует одна `major collection`. Числа до и после стрелки, например, `325407K-> 83000K`, указывают размер живых объектов до и после сборки мусора, соответственно. 



После `minor collections` ???

Размер включает некоторые объекты, которые являются мусором (больше не живы), но не могут быть удалены. Эти объекты либо содержатся в `tenured generation`, либо ссылаются на `tenured generation`.

After minor collections, the size includes some objects that are garbage (no longer alive) but cannot be reclaimed. These objects are either contained in the tenured generation or referenced from the tenured generation.



Число в скобках, например `(776768K)`- это размер выделленой памяти в `heap`. 

Обратите внимание, что это число включает только одно областей `Survivor`. 

За исключением случаев сбора мусора, в любой момент времени для хранения объектов будет использоваться только одно `Survivor`.

Время `0.2300771 secs`  показывает за сколько была обработана коллекция.



## Команда `-XX:+PrintGCDetails`

Команда `-XX: + PrintGCDetails` выводит дополнительную информацию:

```bash
[GC [DefNew: 64575K->959K(64576K), 0.0457646 secs] 196016K->133633K(261184K), 0.0459067 secs]
```

- Цифры `DefNew: 64575K-> 959K (64576K)` показываеют, что `minor collection` восстановила около 98% памяти и заняло `0,0457646 secs`.
- Цифры `196016K-> 133633K (261184K)` показывают как сборка мусора повлияла на общий размере `heap`'а, то есть стало доступно ~50% памяти. Общее время `0,0459067 secs` включает время восстановления `minor collection` + дополнительные расходы.



## Команда `-XX:+PrintGCTimeStamps `

Команда `-XX:+PrintGCTimeStamps` добавляет `timestamp` начала сборки мусора, используется для того, чтобы узнать как часто запускается `GC`.

```bash
111.042: [GC 111.042: [DefNew: 8128K->8128K(8128K), 0.0000505 secs]111.042: [Tenured: 18154K->2311K(24576K), 0.1290354 secs] 26282K->2311K(32704K), 0.1293306 secs]
```

- Цифры `111.042` означают, что сборка мусора началась через 111 секунд после старта приложения.
- Вторая цифра `111.042` означает, что сборка `minor collection` началась в то же время.
- Также вывелась информация о `Tenured collection`.





# Доступные сборщики

`JVM HotSpot` включает в себя три различных сборщика мусора:

- Последовательный сборщик (`The serial collector`) .

  - Использует один поток для выполнения всей работы по сбору мусора, что делает его относительно эффективным, потому что нет никаких коммуникационных издержек между потоками. 
  - Лучше всего подходит для однопроцессорных машин, но также может быть полезен на многопроцессорных системах c размером `heap` примерно до 100 МБ.
  - Включается с помощью команды `-XX: +UseSerialGC`.

- Параллельный сборщик (`The parallel collector or the throughput collector`)

  - Работает также как последовательный, но для сборки мусора использует несколько потоков.
  - Предназначен для приложений с наборами данных среднего и большого размера, которые работают на многопроцессорном или многопоточном оборудовании. 
  - Включается с помощью команды `-XX: +UseParallelGC`.
  - `Parallel compaction` - это опция, которая включает параллельную сборку мусора в `major collection`. Без этой опции сборка мусора для `major collection` будет использовать один поток.
  - По умолчанию включена, если включена `-XX:+UseParallelGC`.
  - Может быть выключена с помощью `-XX:-UseParallelOldGC`.

- Максимально параллельные сборщики (`The mostly concurrent collector`)

  - Выполняют большинство работы параллельно, то есть даже когда работает приложение, чтобы обеспечить минимальные паузы при сборке мусора.
  - ` JVM HotSpot ` предлагает два сборщика: `CMS` и `G1`.
  - Сборщики предназначены для приложений со средним и большим размером `heap` в которых время отклика важнее, чем общая пропускная способность, та как методы, используемые для минимизации пауз, могут снизить производительность приложений.
  - Используйте параметр `-XX: +UseConcMarkSweepGC` для включения сборщика `CMS` или `-XX: +UseG1GC` для включения сборщика `G1`.

  



## Выбор сборщика мусора

Если ваше приложение не предъявляет достаточно строгих требований к времени паузы, сначала запустите ваше приложение и позвольте виртуальной машине выбрать коллектор. При необходимости отрегулируйте размер кучи для повышения производительности. Если производительность по-прежнему не соответствует вашим целям, используйте следующие рекомендации в качестве отправной точки для выбора коллектора.

- Если приложение имеет небольшой набор данных (примерно до 100 МБ), то выберите последовательный коллектор с опцией -XX: + UseSerialGC.
- Если приложение будет запущено на одном процессоре и нет требований к времени паузы, тогда позвольте виртуальной машине выбрать коллектор или выбрать последовательный коллектор с опцией -XX: + UseSerialGC.
- Если (а) пиковая производительность приложения является первым приоритетом и (б) нет требований к времени паузы или допустимы паузы в 1 секунду или более, тогда позвольте виртуальной машине выбрать коллектор или выбрать параллельный коллектор с помощью -XX: + UseParallelGC.
- Если время отклика важнее, чем общая пропускная способность, и паузы при сборке мусора должны быть короче, чем приблизительно 1 секунда, выберите параллельный сборщик с -XX: + UseConcMarkSweepGC или -XX: + UseG1GC.



Эти рекомендации предоставляют только отправную точку для выбора сборщика мусора, поскольку производительность зависит 

- от размера кучи (`heap`), 
- количества живых объектов в приложении и 
- числа и производительности используемых процессоров.

Время паузы особенно чувствительно к этим факторам, поэтому упомянутый ранее порог в 1 секунду является лишь приблизительным: 

параллельный коллектор (` the parallel collector`) будет иметь длительность паузы, превышающую 1 секунду, для многих комбинаций размера кучи и оборудования; 

и наоборот, параллельный коллектор (`the concurrent collector`) может не поддерживать паузы короче 1 секунды в некоторых комбинациях.

Если рекомендуемый сборщик не достигает желаемой производительности, сначала попытайтесь отрегулировать кучу и размеры `minor and major collections`. 

Если производительность по-прежнему недостаточна, попробуйте другой сборщик: используйте параллельный сборщик (`the concurrent collector`), чтобы уменьшить время паузы, и используйте параллельный сборщик (`the parallel collector`), чтобы увеличить общую пропускную способность на многопроцессорном оборудовании.





# Последовательный сборщик (`Serial collector`)

Последовательный сборщик (`Serial collector`) обычно подходит для небольших приложений на однопроцессорных машинах с размером `heap` примерно до 100MB. 

**TODO**

Использование параллельных коллекторов не рекомендуется в таких условиях, так как они имеют дополнительные накладные расходы и сложность, что является ценой за специализированное поведени.





# Параллельный сборщик (`The Parallel Collector` or `The Throughput Collector`)

Параллельный сборщик (`The Parallel Collector` or `The Throughput Collector`) работает также как и последовательный сборщик, основное отличие в том, что для ускорения сбора мусора используется несколько потоков.

Параллельный сборщик включается так:

```bash
java -XX:+UseParallelGC -Xmx2g -Xms32m -jar app.jar 10
```

По умолчанию, при использовании этой опции, сборка мусора выполняется параллельно во всех поколениях.

- Параллельный сборщик выбран по умолчанию на машинах серверного класса.



## Сколько ядер используется?

- На машинах с 8 ядрами и более, параллельный сборщик использует 5/8 ресурсов,
- на машинах с менее 8 ядрами, доля уменьшается до 5/16,
- можно настроить конкретное число потоков с помощью команды`-XX: ParallelGCThreads = <N>`.



## Параллельный сборщик VS Последовательный сборщик

- **Ядер = 1**. На машине с одним ядром параллельный сборщик, не будет работать также хорошо как и последовательный сборщик, из-за накладных расходов (синхронизации и тд).

- **Ядер = 2**. На двух ядрах параллельный сборщик обычно превосходит последовательный на скромную велечину.

- **Ядер > 2**. Кода доступно более двух ядер паралелльный сборщик обычно значительно лучше, чем последовательный.

  

## Эффект фрагментации

- Для обеспечения хорошей производительности при использовании последовательного или параллельного сборщика **размер `Heap`'а не отличается**.

- Включение параллельного сборщика должно сделать паузы сбора короче.

- А также при использовании параллельного-сборщика может наблюдаться эффект фрагментации. Когда несколько потоков обрабатывают `young generation` и передвигают объекты в `tenured generation`, потоки резервируют части памяти (`"promotion buffers"`) в `tenured generation`, данный процесс может стать причиной фрагментации. 

  - Уменьшение количества потоков сборки мусора и увеличение размера `tenured generation` уменьшит эффект фрагментации.

  

## Поколения (`Generations`)

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_002_armgnt_gn_pl.png)



## Эргономика параллельного сборщика (`Parallel Collector Ergonomics`)

- Кроме того, в параллельном коллекторе используется метод автоматической настройки, который позовляет выбирать специализированное поведение, вместо низко-уровневной настройки.
- Вы можете указать максимальное время приостановки сбора мусора, пропускную способность и площадь (размер кучи).
- **Максимальная пауза GC**
  - По умолчанию нет максимальной времени паузы,
  - чтобы указать, используется команда `-XX:MaxGCPauseMillis=<N>`.
  - Команда интерпретируется как подсказка, что желательное времени паузы должно быть меньше чем `N` милисекунд.
  - Если задана "максимальная пауза", тогда размер `heap` и другие параметра, коректируются, чтобы достичь цели. Эти корректировки могут привести к уменьшению общей пропускной способности приложения и желаемая цель также может быть не достигнута.
- **Пропускная способность (`Throughput`) **
  - Цель пропускной способности измеряется с точки зрения времени, потраченного на сборку мусора, по сравнению с временем, потраченным вне сбора мусора (называемое временем приложения).
  - Цель задается параметром командной строки `-XX: GCTimeRatio = <N>`, который устанавливает отношение времени сборки мусора к времени приложения в `1 / (1 + <N>)`.
- **Footprint**
  - Максимальный размер кучи указывается с помощью опции `-Xmx <N>`. Кроме того, сборщик имеет неявную цель минимизировать размер кучи, пока выполняются другие цели.



## Приоритеты целей

Цели решаются в следующем порядке:

- Максимальное время паузы
- Пропускная способность
- Минимальная цель следа

Максимальное время паузы достигается первым. Только после того, как это достигнуто, цель пропускной способности адресована. Точно так же, только после того, как первые две цели были достигнуты, рассматривается цель следа.



## Корректировка `Generations`

- Статистика средней времени паузы обновляется каждый раз после обработки каждой коллекций `generations`.
- Затем выполняются тесты для определения того, были ли достигнуты цели и вносятся необходимые корректировки в размер `generations`.
- Исключение, то есть статистика не собирается, при явных вызовах сборщика мусора (`Systems.gc()`).



## Увеличение и уменьшение размера `generations` 

- Увеличение и уменьшение размера `generation` измеряется в процентах от размера поколения.
- Рост и сжатие осуществляется с разными величинами.
- По умолчанию `generations` увеличивается на 20%, а уменьшается на 5%.
- Для `young generation` процесс роста задаётся командой `-XX: YoungGenerationSizeIncrement = <Y>`
- Для `turned generation` - `-XX: TenuredGenerationSizeIncrement = <T>`
- Процент сжатия настраивается командой `-XX: AdaptiveSizeDecrementScaleFactor = <D>`, если прирост составляет `X` процентов, то уменьшение при сокращении составляет `X/D` процентов.
- При запуске приложения может добавляться дополнительный процент к увеличения `generation`, этот эффект не долгосрочный. Целью является повышения производительности при запуске.
- Если максимальное время паузы не достигается, тогда размер только одного поколения `generation` сокращается за раз. Если время паузы обоих поколений выше цели, то размер поколения с большим временем паузы сокращается первым.
- Если цель пропускной способности не достигается, размеры обоих поколений увеличиваются. Каждое поколение увеличивается пропорционально вкладу в общее время сбора мусора.  Например, если время сбора мусора молодого поколения составляет 25% от общего времени сбора, и если полный прирост поколений будет на 20%, то молодое поколение будет увеличено на 5%.



## Дефолтный размер `Heap` для `Client JVM`

- Если не указан начальный и максимальный размеры кучи через командную строку, значения рассчитываются на основе объема памяти на машине.
- Максимальный размер кучи, равен
  - 1/2 физической памяти, если на машине до 192MB;
    - Если на машине 128MB, то максимальный размер - 64MB.
  - 1/4 физической памяти (но не больше 1GB), если на машине больше 192MB.
    - Если на машине 1GB, то максимальный размер - 256MB.
- Минимальный размер кучи (`initial heap size`), равен
  - минимум 8MB или 1/64 физической памяти (но не больше 1GB).
- Максимальный размер `young generation` = 1/3 `heap`.



## Дефолтный размер `Heap` для `Server JVM`

- На `32-bit JVMs` может достигать 1GB, если на машине 4GB или больше.
- На `64-bit JVMs` может достигать 32GB, если на машине 128GB или больше.



## Указать начальный и максимальный размер `heap`

- `-Xms` -  (initial heap size)

- `-Xmx` - (maximum heap size)

- Если вы знаете какой размер `heap` нужен для вашего приложения, можете установить `-Xms` и `-Xmx` в одно и то же значение. Если нет, `JVM` запустится с использованием начального размера кучи, а затем будет увеличивать кучу, пока не найдет баланс между использованием кучи и производительностью.

- Для проверки дефолтных значений используйте команду `-XX:+PrintFlagsFinal` .

  ```bash
  java -XX:+PrintFlagsFinal <GC options> -version | grep MaxHeapSize
  ```

  

## Excessive GC Time and OutOfMemoryError

Параллельный сборщик выдает ошибку OutOfMemoryError, если слишком много времени тратится на сборку мусора (GC):

- Если на сборку мусора уходит более 98% общего времени и восстанавливается менее 2% кучи, то генерируется ошибка OutOfMemoryError
- Эта функция предназначена для предотвращения длительного периода работы при ничтожном прогрессе, поскольку куча слишком мала.
- При необходимости эту функцию можно отключить, добавив параметр `-XX: -UseGCOverheadLimit`.





# Максимально-параллельные сборщики мусора

`JVM Hotspot`имеет два максимально-параллельных сборщика мусора в `JDK 8`:

- `Concurrent Mark Sweep (CMS) Collector` - это коллектор предназначен для приложений, которые предпочитают более короткие паузы сбора мусора и могут позволить себе совместно использовать ресурсы процессора при сборке мусора.
- `Garbage-First Garbage Collector` - это серверный коллектор предназначен для многопроцессорных машин с большим объемом памяти. Он с высокой вероятностью отвечает целевым показателям времени паузы при достижении высокой пропускной способности.



## Накладные расходы параллелизма

`The mostly concurrent collector` тратит ресурсы процессора, (которые в противном случае были бы доступны приложению) для достижения более коротких пауз при сборке мусора в `major collecton`.

Наиболее заметные накладные расходы - это использование одного или нескольких процессоров во время параллельной работы над  коллекциями `collection.`

В `N` процессорной системе параллельная часть работ с `collection` будет использовать `K/N` доступных процессоров, где `1 <= K <= потолок {N / 4}`. (Обратите внимание, что значение K предмет выбора.) 

В дополнение к использованию процессоров во время `concurrent phases`, дополнительные издержки возникают для обеспечения параллелизма.

Таким образом, хотя паузы при сборке мусора обычно намного короче с `the concurrent collector`, пропускная способность приложения также имеет тенденцию быть немного ниже, чем с другими сборщиками.

На машине с более чем одним ядром, процессоры доступны для работы приложения во время сборки мусора, поэтому, поэтому `the concurrent garbage collector` не «приостанавливает» приложение.

Обычно это приводит к более коротким паузам, но опять-таки приложению доступно меньше ресурсов процессора, и следует ожидать некоторого замедления, особенно если приложение максимально использует все ядра.

По мере увеличения числа процессоров `N`, нехватка ресурсов процесса становится меньше, а преимущество от использования одновременного сбора мусора увеличивается.

В разделе `Concurrent Mode Failure` в сборщике `CMS` обсуждаются потенциальные ограничения для такого масштабирования.



Поскольку по крайней мере один процессор используется для сбора мусора во время `concurrent phases`, `the concurrent collectors` обычно не дают никаких преимуществ на однопроцессорной (одноядерной) машине.

Однако для `CMS` доступен отдельный режим (не `G1`), который позволяет достигать низких пауз в системах с одним или двумя процессорами; подробности см. ` Incremental Mode in Concurrent Mark Sweep (CMS) Collector`.



# Concurrent Mark Sweep (CMS) Collector

`The Concurrent Mark Sweep (CMS) ` предназначен для приложений, которые предпочитают более короткие паузы сбора мусора и которые могут предоставить ресурсы процессора совместно с сборщиком мусора во время работы приложения.

Обычно приложения, которые имеют относительно большой набор долгоживущих данных (`a large tenured generation`) и работают на машинах с двумя или более процессорами, имеют тенденцию извлекать выгоду из использования этого сборщика.

Тем не менее, этот коллектор следует рассматривать для любого применения с низким требованием времени паузы. 

Сборщик CMS включается с параметром командной строки -XX: + UseConcMarkSweepGC.

--

Подобно другим доступным коллекторам, коллектор CMS обрабатывает все поколения, то есть `minor and major collections`.

Сборщик `CMS` пытается сократить время пауз из-за больших сборок, используя отдельные потоки сборщика мусора для отслеживания достижимых объектов одновременно с выполнением потоков приложения.

Во время каждого сбора мусора в `major collection` сборщик CMS приостанавливает все потоки приложений на короткий период в начале работы над `collection`, а затем в середине.

Вторая пауза обычно длиннее. Несколько потоков используются для выполнения сбора мусора во время обеих пауз.

Остальная часть коллекции (включая большую часть отслеживания живых объектов и очистки недоступных объектов) выполняется с помощью одного или нескольких потоков сборщика мусора, которые работают одновременно с приложением.

`Minor collections` могут чередоваться с `major collections` и обрабатываются аналогично параллельному коллектору (в частности, потоки приложения останавливаются во время `minor collections`).



## Concurrent Mode Failure

Сборщик `CMS` использует один или несколько потоков для сбора мусора, которые запускаются одновременно с потоками приложения с целью убирать мусор в  `tenured generation` до его заполнения.

Как описано ранее, при нормальной работе сборщик `CMS` выполняет большую часть своей работы по отслеживанию и удалению мусора параллельно с потомками приложения, поэтому потоки приложения останавливаются только на короткие паузы.

Однако, если сборщик `CMS` не может завершить восстановление недоступных объектов до того, как заполнение `tenured generation`, или если `allocation` не может быть удовлетворено доступными блоками свободного пространства в `tenured generation`, тогда приложение приостанавливается, и сбор мусора происходит когда все потоки приложений остановлены.

Невозможность паралельного сбора мусора и работы приложения называется `concurrent mode failure` и указывает на необходимость настройки `CMS`.

Если `concurrent collection` прерывается явным вызовом сборкщика мусора (`System.gc ()`) или сборкой мусора, необходимой для предоставления информации для диагностических инструментов, то случается  `concurrent mode interruption`.



## Excessive GC Time and OutOfMemoryError

Сборщик CMS выдает ошибку OutOfMemoryError, если на сборку мусора уходит слишком много времени: если на сборку мусора уходит более 98% общего времени и восстанавливается менее 2% кучи, то генерируется ошибка OutOfMemoryError.

Эта функция предназначена для предотвращения запуска приложений в течение длительного периода времени при небольшом прогрессе или его отсутствии, поскольку куча слишком мала.

При необходимости эту функцию можно отключить, добавив параметр -XX: -UseGCOverheadLimit в командную строку.

--

Политика такая же, как в параллельном сборщике, за исключением того, что время, затрачиваемое на выполнение одновременных сборов, не засчитывается в ограничение времени 98%. 

Другими словами, только сборы, выполненные в то время, когда приложение остановлено, засчитываются в чрезмерное время GC.

Такие коллекции обычно происходят из-за сбоя одновременного режима или явного запроса сбора (например, вызова System.gc).



## Floating Garbage

Сборщик `CMS`, как и все другие сборщики в `Java HotSpot VM`, является сборщиком трассировки, который идентифицирует по крайней мере все достижимые объекты в куче. На языке Ричарда Джонса и Рафаэля Д.  в своей публикации `Garbage Collection: Algorithms for Automated Dynamic Memory`, это инкрементный сборщик обновлений ` it is an incremental update collector`.

Поскольку потоки приложения и потоки сборки мусора мусора выполняются одновременно во время обработки `major collection`, объекты, которые отслеживаются сборщика мусора, могут впоследствии стать недоступными к концу процесса сборки.

Такие недоступные объекты, которые еще не были утилизированы, называются плавающим мусором. Количество плавающего мусора зависит от продолжительности цикла одновременного сбора и от частоты обновления ссылки, также известного как `mutations`, приложением.

Кроме того, поскольку `young generation` и `tenured generation` собираются независимо, каждое из них служит источником корней для другого.

В качестве грубого ориентира, попробуйте увеличить размер `tenured generation` на 20%, чтобы учесть плавающий мусор.

Плавающий мусор оставщийся в куче в конце одного параллельного сбора собирается во время следующего паралельного сбора.



Что такое плавающий мусор?

В чем проблема удалить такой мусор?



## Pauses

Параллельная трассировка графа достижимых объектов происходит между начальной паузой `mark pause` отметки и паузой примечания `remark pause`.

Во время этой параллельной фазы трассировки один или несколько параллельных потоков сборщика мусора могут использовать ресурсы процессора, которые в противном случае были бы доступны для приложения.

В результате приложения, привязанные к вычислениям, могут увидеть соразмерное падение пропускной способности приложений на этом и других параллельных этапах, даже если потоки приложений не приостановлены.

После  `remark pause` сборщик собирает объекты, идентифицированные как недоступные. 

Как только цикл сбора завершен, сборщик CMS ждет, почти не потребляя вычислительных ресурсов, до начала следующего сбора `major collection`.



Какие паузы существуют, когда они происходят и что можно сказать о длительности пауз?

Что делает сборщик после `init and remark pause`?

Когда сборку мусора нет, что делается с потоками?

Concurrent vs Parallel?



## Starting a Concurrent Collection Cycle

С помощью ` the serial collector` отчистка `major collection` происходит, когда ` tenured generation` становится заполненным, и все потоки приложения останавливаются во время сборки мусора.

Напротив, начало `concurrent collection` должно быть рассчитано так, чтобы коллекция сборка мусора могла завершиться до того, как `tenured generation` станет полным; в противном случае приложение будет наблюдать более длинные паузы из-за `concurrent mode failure`.

Есть несколько способов начать `concurrent collection`.

--

Основываясь на истории своей предыдущей работы, сборщик CMS поддерживает оценку времени, оставшегую до тока как `tenured generation` будет израсходовано, и времени, необходимого для `concurrent collection cycle`.

Используя эти динамические оценки, запускается `concurrent collection cycle` с целью завершения цикла сбора до того, как `tenured generation` будет заполнено.

Эти оценки добавлены для безопасности, потому что `concurrent mode failure` может быть очень дорогостоящим.

--

`Concurrent collection` также начинается, если заполненность `tenured generation` превышает  `initiating occupancy` (процент от `tenured generation`).

Значение по умолчанию для `initiating occupancy` составляет приблизительно 92%, но это значение может изменяться от релиза к релизу.

Это значение можно настроить вручную с помощью параметра командной строки `-XX: CMSInitiatingOccupancyFraction = <N>`, где `<N>` - это целое процентное значение (от 0 до 100) от размера `tenured generation`.



## Scheduling Pauses

Паузы для `young generation` и `tenured generation` происходят независимо. 

Они не накладываеются друг на друга, но могут происходить последовательно, то есть пауза для сборки мусора в одном поколенни, и сразу следующая пауза для сборки в другой `collection`, может выглядеть как одна более длинная пауза.

Чтобы избежать этого, сборщик `CMS` пытается запланировать `remark pause` примерно посередине между предыдущим и следующим паузами для сборку мусора в  `young generation`.

Это планирование не выполняется для паузы ` initial mark`, которая обычно намного короче, чем `remark pause`.



## Incremental Mode

Обратите внимание, что инкрементный режим считается устаревшим в Java SE 8 и может быть удален в будущем основном выпуске.

--

Коллектор CMS может использоваться в режиме, в котором `concurrent phases` и выполняться `incrementally`.

Напомним, что во время параллельной фазы поток сборщика мусора использует один или несколько процессоров.

Инкрементный режим предназначен для уменьшения влияния длинных параллельных фаз путем периодической остановки `concurrent phase`, чтобы вернуть процессор в приложение.

Этот режим, называемый здесь `i-cms`, делит работу, выполняемую одновременно сборщиком, на небольшие отрезки времени, запланированные между сбором мусора в `young generation`.

Эта функция полезна, когда приложения, которым требуется низкое время паузы, предоставляемое сборщиком CMS, запускаются на машинах с небольшим числом процессоров (например, 1 или 2).

Параллельный цикл сбора обычно включает в себя следующие этапы:

- Останавливает все потоки приложения, определяет набор объектов, достижимых из корней, а затем возвращает все потоки приложению.

- `Concurrently` отслеживает граф достижимых объектов, используя один или несколько процессоров, пока выполняются потоки приложения.

- `Concurrently` восстанавливает разделы графа объектов, которые были изменены с момента трассировки на предыдущем шаге, используется один процессор.

- Остановливает все потоки приложения и восстанавливает все разделы корней и графа объектов, которые могли быть изменены с момента их последнего изучения, а затем возобновите все потоки приложения.

- Одновременно убирает недоступные объекты для отчистки коллекций, используемые для `allocation`, используется один процессор.

- Одновременно изменяется размер кучи и подготавливается вспомогательные структуры данных для следующего цикла сбора, используется один процессор.

  

Как правило, сборщик CMS использует один или несколько процессоров в течение всей фазы `concurrent` отслеживания, без добровольного отказа от них.

Точно так же один процессор используется для всей `concurrent` фазы удаления объектов, опять же, не отказываясь от него.

Эти издержки могут быть слишком серьезными для приложений с ограничениями по времени отклика, которые в противном случае могли бы использовать ядра обработки, особенно при работе в системах с одним или двумя процессорами.

Инкрементальный режим решает эту проблему, разбивая параллельные фазы на короткие всплески активности, которые запланирово случаются между `minor pauses`.

--

В режиме `i-cms` используется рабочий цикл для контроля объема работы, которую коллектор CMS может выполнять перед тем, как добровольно отказаться от процессора.

Рабочий цикл - это процент времени между сборами мусора в `young generation` , который разрешен `CMS` сборщику для работы.

Режим `i-cms` может автоматически вычислять `duty cycle` на основе поведения приложения (рекомендуемый метод, известный как `automatic pacing` ), или `duty cycle`  может быть установлен в фиксированное значение в командной строке.



Что такое `duty cycle`? Зачем он считается?



## Command-Line Options

Table 8-1, "Command-Line Options for i-cms" , перечисляет параметры командной строки, которые управляют режимом i-cms. В разделе «Recommended Options» предлагается начальный набор параметров.

`-XX: +CMSIncrementalMode` - Включает инкрементный режим. Обратите внимание, что коллектор CMS также должен быть включен (с `-XX: +UseConcMarkSweepGC`), чтобы эта опция работала. Отключена по умолчанию.



## Recommended Options

Чтобы использовать i-cms в Java SE 8, используйте следующие параметры командной строки:

````bash
-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode \
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps
````

Первые две опции включают сборщик CMS и i-cms соответственно. Последние две команды не требуются; они просто приводят к тому, что диагностическая информация о сборке мусора записывается в стандартный вывод, так что поведение сборки мусора можно увидеть и позже проанализировать.



## Basic Troubleshooting

Функция `automatic pacing` i-cms использует статистику, собранную во время работы программы, для вычисления `duty cycle`, чтобы `concurrent collections` завершались до заполнения кучи.

Тем не менее, поведение в прошлом не является идеальным предиктором поведения в будущем, и оценки не всегда могут быть достаточно точными, чтобы предотвратить переполнение кучи.

Если происходит слишком много сбора мусора в коллекциях, попробуйте выполнить шаги, указанные в  Table 8-2, "Troubleshooting the i-cms Automatic Pacing Feature", по одной за раз.

1. Увеличьте коэффициент безопасности. `-XX: CMSIncrementalSafetyFactor = <N>`
2. Увеличьте минимальный `duty cycle.`. `-XX: CMSIncrementalDutyCycleMin = <N>`
3. Отключите `automatic pacing` и используйте фиксированный `duty cycle`. `-XX: -CMSIncrementalPacing -XX: CMSIncrementalDutyCycle = <N>`



## Measurements

Example 8-1, "Output from the CMS Collector" - это вывод из CMS Collector с параметрами `-verbose: gc` и `-XX: + PrintGCDetails`, с удалением нескольких незначительных деталей. 

Обратите внимание, что выходные данные для сборщика CMS чередуются с выходными данными из `minor collections` ; как правило, многие `minor collections` убираются в `concurrent collection`.

CMS-initial-mark указывает начало `concurrent collection`, CMS-concurrent-mark указывает конец `concurrent collection`, а `CMS-concurrent-sweep` отмечает конец фазы `concurrent sweeping phase`.

Ранее не обсуждался этап предварительной очистки, обозначенный как `CMS-concurrent-preclean`.

Предварительная очистка представляет собой работу, которая может выполняться одновременно при подготовке к `remark phase CMS-remark`.

Последний этап обозначен `CMS-concurrent-reset` и находится в стадии подготовки к следующей `concurrent collection`.

**Example 8-1 Output from the CMS Collector**

````bash
[GC [1 CMS-initial-mark: 13991K(20288K)] 14103K(22400K), 0.0023781 secs]
[GC [DefNew: 2112K->64K(2112K), 0.0837052 secs] 16103K->15476K(22400K), 0.0838519 secs]
...
[GC [DefNew: 2077K->63K(2112K), 0.0126205 secs] 17552K->15855K(22400K), 0.0127482 secs]
[CMS-concurrent-mark: 0.267/0.374 secs]
[GC [DefNew: 2111K->64K(2112K), 0.0190851 secs] 17903K->16154K(22400K), 0.0191903 secs]
[CMS-concurrent-preclean: 0.044/0.064 secs]
[GC [1 CMS-remark: 16090K(20288K)] 17242K(22400K), 0.0210460 secs]
[GC [DefNew: 2112K->63K(2112K), 0.0716116 secs] 18177K->17382K(22400K), 0.0718204 secs]
[GC [DefNew: 2111K->63K(2112K), 0.0830392 secs] 19363K->18757K(22400K), 0.0832943 secs]
...
[GC [DefNew: 2111K->0K(2112K), 0.0035190 secs] 17527K->15479K(22400K), 0.0036052 secs]
[CMS-concurrent-sweep: 0.291/0.662 secs]
[GC [DefNew: 2048K->0K(2112K), 0.0013347 secs] 17527K->15479K(27912K), 0.0014231 secs]
[CMS-concurrent-reset: 0.016/0.016 secs]
[GC [DefNew: 2048K->1K(2112K), 0.0013936 secs] 17527K->15479K(27912K), 0.0014814 secs
]
````

Начальная пауза метки обычно коротка относительно `minor collection pause time`. `The concurrent phases` (`concurrent mark`, `concurrent preclean and concurrent sweep`) обычно длятся значительно дольше, чем `minor collection pause`, как указано в примере Example 8-1, "Output from the CMS Collector".

Однако обратите внимание, что приложение не приостанавливается на этих `concurrent phases`. `The remark pause` часто сопоставима по длине с `minor collection`.

`The remark pause` влияют определенные характеристики приложения (например, высокая скорость изменения объекта может увеличить эту паузу) и время, прошедшее с момента последней `minor collection`  (например, большее количество объектов в `young generation` может увеличить эту паузу).



# Сборщик мусора G1 (`Garbage-First Garbage Collector`) 

## Зачем?

Сборка мусора - это баланс между паузами на сборку мусора и пропускной способностью приложения. `G1` - это сборщик мусора, который пытается достичь минимальных пауз с сохранением высокой пропускной способности. 

Достичь этого удается за счет большого потребления ресурсов:

- большого размера `heap`'а,
- параллельного использования ресурсов процессора сборщиком мусора и приложением.

В цифрах это означает размер кучи около 6 ГБ или более, а также стабильное и предсказуемое время паузы ниже 0,5 секунд.



## Принципы работы

- `G1` нацелен выполнять работу параллельно:
  - выполняет маркировку объектов постоянно, одновременно с работой приложения;
  - выполняет параллельную сборку мусора в молодом и старом поколении - `mixed collection`;
  - выполняет параллельную отчистку регионов.
- `G1` делит `heap` на небольшие одинаковые регионы - непрерывные куски памяти, что позволяет:
  - быстро обрабатывать регионы,
  - прогнозировать время обработки,
  - эффективно использовать регионы для поколений, то есть использовать 
    - новые регионы для молодого поколения,
    - формировать `survivor` и `turned generation`, путем продвижения выживших объектов,
  - уменьшать фрагментацию и "сжимать" `heap` при продвижении объектов,
  - обрабатывать регионы и поколения независимо и параллельно (`mixed collection`).



## `G1` делит `heap` на регионы

`G1` делит кучу на куски одинакового размера, каждый из которых представляет непрерывный диапазон виртуальной памяти. Размеры региона могут варьироваться от 1 МБ до 32 МБ в зависимости от размера кучи. Цель - иметь не более 2048 регионов.

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_004_grbg_frst_hp.png)

На рисунке обозначены:

- серым цветом - пустые регионы,
- синим - `eden` регионы,
- буквой `S` - `survivor` регионы,
- красным - регионы старого поколения (`tunered generaion`),
- буквой `H` - громадные объекты.

Объекты выделяются в регионах `eden`, когда такие регионы заполняются, в них происходит дешевая сборка мусора, а выжившие объекты перемещаются в `survivor`. В случае заполнения `survivor`, так же происходит сборка мусора и выжившие объекты продвигаются по поколениям далее, так происходит дефрагментация и уплотнение поколений. Если в существующих регионах `eden/survivor/tunered generation` нет места, то объекты перемещаются в пустые регионы, которые маркируются соответствующе. Регионы, отмеченные буквой «H», содержат огромные объекты, которые занимают больше половины региона.



## Фаза работы `G1`

G1 использует модель прогнозирования паузы для достижения заданного пользователем целевого времени паузы и выбирает количество областей для сбора на основе заданного целевого времени паузы.





- `Initial marking phase`

  - Выполняется STW
  - Отмечаются регионы с объектами (с корнями), которые могут ссылаться на старое поколение

- `Root region scanning phase`:

  - Не выполняется STW -> Происходит параллельная работа с приложением
  - Сканируются регионы, отмеченные на этапе `Initial marking phase`, отмечаются объекты (`referenced objects`), которые ссылаются на `old generation`

- `Concurrent marking phase`:

  - Не выполняется STW, но фаза может быть прервана STW -> Происходит параллельная работа с приложением
  - Определяются живые объекты в `heap`.
  - После завершения `marking phase` `G1` знает, какие области в основном пусты и эти области будут отчищенны впервую очередь, вот почему метод сбора мусора называется `Garbage-Firtst`.

- `Remark phase`:

  - Выполняется STW

  - Отчищается SATB, записывает непосещенные живые объекты, и выполняется обработка ссылок.

- `Cleanup phase`:
  - Выполняется STW -> фаза выполняется частично параллельно
  - Сначала собираются регионы c большим числом мусора, как правило молодое поколение, чтобы дать как можно большое количестов свободного пространства, 
  - Отчистка регионов, отчистка RSet, поиск регионов для следующей сборки мусора.





Вопросы, что такое корни? `referenced objects` - это корни.







## `G1` нацелен выполнять работу параллельно

`G1` работает над `heap`'ом параллельно с приложением, то есть постоянно выполняется глобальная маркировка объектов в `heap`. Это предотвращает проблему длительных пауз пропорциональных размеру `heap` или размеру живых объектов (`live-data`).













--

G1 копирует объекты из одной или нескольких областей кучи в одну область в куче, и в процессе сжатия и освобождения памяти.

Эта эвакуация выполняется параллельно на многопроцессорных системах для уменьшения времени паузы и увеличения пропускной способности.

Таким образом, с каждой сборкой мусора G1 постоянно работает над уменьшением фрагментации.

Это выше возможностей обоих предыдущих методов.

Сборка мусора в CMS (Concurrent Mark Sweep) не выполняет сжатие.

`Parallel compaction` выполняет только сжатие всей кучи, что приводит к значительным временам паузы.

--

`G1` способен параллельно делать сборку мусора в молодом и старом поколении - `mixed collection`.



Сборщик мусора (`The garbage collection`) - это `compacting collection`, которая копирует живые объекты в выбранные, изначально пустые области.





Важно отметить, что G1 не является `real-time collector`. 

Это соответствует заданному времени паузы с высокой вероятностью, но не абсолютной уверенностью.

На основе данных из предыдущих сборов мусора G1 оценивает, сколько регионов может быть собрано за целевое время.

Таким образом, сборщик имеет достаточно точную модель стоимости сбора регионов, и он использует эту модель, чтобы определить, какие и сколько регионов собирать, оставаясь в рамках целевого времени паузы.

--

Первым направлением G1 является предоставление решения для пользователей, работающих с приложениями, которым требуются большие кучи с ограниченной задержкой на уборку мусора.

Это означает размер кучи около 6 ГБ или более, а также стабильное и предсказуемое время паузы ниже 0,5 секунды.

--

Приложения, работающие сегодня с CMS или с ` parallel compaction`, выиграют от переключения на G1, если приложение имеет одну или несколько из следующих характеристик.

- Более 50% кучи Java занято живыми данными.
- Скорость `allocation` или продвижения по службе значительно варьируется.
- Приложение испытывает нежелательные длительные паузы `garbage collection or compaction pauses` (дольше, чем от 0,5 до 1 секунды).

--

G1 планируется в качестве долгосрочной замены для `Concurrent Mark-Sweep Collector (CMS).`

Сравнение G1 с CMS выявляет различия, которые делают G1 лучшим решением.

Одно отличие состоит в том, что G1 является уплотняющим коллектором.

Кроме того, G1 предлагает более предсказуемые паузы сбора мусора, чем сборщик CMS, и позволяет пользователям указывать желаемые цели паузы.

--

Как и в случае с CMS, G1 предназначен для приложений, требующих более коротких пауз сборок мусора.



## Allocation (Evacuation) Failure

Как и в случае с CMS, сборщик G1 запускает часть сборок мусора, в то время как приложение продолжает работать, и существует риск, что приложение выделит объекты быстрее, чем сборщик мусора сможет восстановить свободное пространство.

См. Раздел ` Concurrent Mode Failure in Concurrent Mark Sweep (CMS) Collector для аналогичного поведения CMS.

В G1 сбой (исчерпание кучи Java) происходит, когда G1 копирует текущие данные из одного региона (эвакуация) в другой регион.

Копирование выполняется для сжатия живых данных.

Если свободная (пустая) область не может быть найдена во время эвакуации региона, в котором происходит сборку мусора, происходит сбой `allocation failure` (поскольку нет места для `allocation` живых объектов из области, подлежащей эвакуации) и тогда делается `stop-the-world`  (STW).



## Floating Garbage

Объекты могут умереть во время сбора G1 и не могут быть собраны.

G1 использует технику, называемую «snapshot-at-the-beginning» (SATB), чтобы гарантировать, что сборщик мусора найдет все живые объекты.

SATB заявляет, что любой объект, который является живым в начале одновременной маркировки (маркировка по всей куче), считается живым lдля всего процеса сборки мусора.

SATB справляется с `floating garbage` способом, аналогичным `CMS incremental update`.



## Pauses

G1 приостанавливает приложение для копирования живых объектов в новые регионы.

Эти паузы могут быть либо `young collection`, где собираются только молодые регионы (`young regions`), либо ` mixed collection` паузы, когда молодые и старые регионы эвакуируются.

Как и в случае с CMS, существует `final marking or remark pause` для завершения маркировки, пока приложение остановлено.

В то время как CMS также имела `initial marking` маркировки, G1 выполняет ` initial marking` как часть `evacuation pause`.

У G1 есть фаза очистки в конце `collection`, которая частично STW и частично `concurrent`.

STW часть этапа очистки определяет пустые области и определяет старые области, которые являются кандидатами для следующей сборки мусора.



## Card Tables and Concurrent Phases

Если сборщик мусора не собирает всю кучу (инкрементный сборщик `incremental collection`), сборщик мусора должен знать, где находятся указатели несобранной части кучи в собираемой кучи (сборщик мусора должен знать где находится мусор в heap'e, который должны быть собраны, но пока что находится в heap'e).

Это обычно для сборщика мусора поколений, в котором несобранная часть кучи обычно является старым поколением `old generation`, а собранная часть кучи - молодым поколением `young generation`.

Структура данных для хранения этой информации (`old generation pointers to young generation objects`) представляет собой `remembered set`.

`Card table` - это особый тип `remembered set`.

Java HotSpot VM использует массив байтов в качестве `card table`.

Каждый байт передается как карта. ???

Карта соответствует диапазону адресов в куче.

`Dirtying a card ` означает изменение значения байта на `dirty value`; `dirty value` может содержать новый указатель `old generation to the young generation` в диапазоне адресов, охватываемом картой.

--

`Processing a card ` означает, что нужно посмотреть на карту, чтобы увидеть, есть ли указатель `old generation to young generation pointer`, и, возможно, сделать что-то с этой информацией, например перенести ее в другую структуру данных.

--

G1 имеет параллельную фазу маркировки, которая отмечает живые объекты, найденные в приложении.

Параллельная маркировка начинается от конца `evacuation pause` (где выполняется `initial marking work`) до `remark`.

Этап `concurrent` очистки добавляет области, освобожденные при сборке мусора, в список свободных областей и очищает запомненные наборы этих областей. 

Кроме того, `concurrent refinement thread` запускается по мере необходимости для обработки записей таблицы карт, которые были загрязнены записями приложения и которые могут иметь межрегиональные ссылки.



## Starting a Concurrent Collection Cycle

Как упоминалось ранее, как в `young and old regions ` мусор собирается в ` mixed collection`.

Чтобы собрать старые регионы, G1 выполняет полную разметку живых объектов в куче.

Такая маркировка выполняется на этапе `concurrent marking phase`.

`Concurrent marking phase` начинается, когда занятость всей кучи Java достигает значения параметра `InitiatingHeapOccupancyPercent`.

Задайте значение этого параметра с помощью параметра командной строки `-XX: InitiatingHeapOccupancyPercent = <NN>`.

Значение по умолчанию `InitiatingHeapOccupancyPercent` составляет 45.



## Pause Time Goal

Установите цель времени паузы для G1 с флагом `MaxGCPauseMillis`.

G1 использует модель прогнозирования, чтобы решить, сколько работы по сбору мусора можно выполнить в течение этого целевого времени паузы.

В конце сборки мусора G1 выбирает регионы, которые будут собраны в следующей сбоки мусора (`the collection set`).

`The collection set` будет содержать `young regions`  (сумма размеров которых определяет логически размер молодого поколения).

Частично посредством выбора количества `young regions` в `collection set ` G1 осуществляет контроль над длиной пауз GC.

Вы можете указать размер ` young generation` в командной строке, как и для других сборщиков мусора, но это может помешать способности G1 достичь целевого времени паузы.

В дополнение к цели времени паузы вы можете указать продолжительность периода времени, в течение которого может произойти пауза.

Вы можете указать `minimum mutator usage` с этим промежутком времени (`GCPauseIntervalMillis`) вместе с целью времени паузы. 

Значение по умолчанию для `MaxGCPauseMillis` составляет 200 миллисекунд.

Значение по умолчанию для `GCPauseIntervalMillis (0)` является эквивалентом отсутствия требований на промежутке времени



# 10 Garbage-First Garbage Collector Tuning

В этом разделе описывается, как адаптировать и настроить сборщик мусора Garbage-First (G1 GC) для оценки, анализа и производительности.

--

Как описано в разделе Garbage-First Garbage Collector, G1 GC является ` regionalized and generational garbage collector`, что означает, что куча Java-объектов (куча) разделена на несколько областей одинакового размера.

После запуска виртуальная машина Java (JVM) устанавливает размер региона.

Размеры региона могут варьироваться от 1 МБ до 32 МБ в зависимости от размера кучи.

Цель - иметь не более 2048 регионов.

`eden`, `survivor` и `old generations` являются логически наборами из этих регионов и регионы не должны быть смежными.

--

У `G1 GC` есть цель времени паузы, которую он пытается достичь (`soft real time`).

Во время `young collections` G1 GC настраивает свое молодое поколение (`eden and survivor sizes`), чтобы соответствовать ` soft real-time target`.

См. Разделы  Pauses and Pause Time Goal in Garbage-First Garbage Collector, чтобы узнать, почему G1 GC делает паузы и как установить целевые значения времени паузы.

--

Во время `mixed collections` G1 GC регулирует количество `old regions`, которые собираются на основе целевого числа смешанных сборок мусора, процента живых объектов в каждой области кучи и общего приемлемого процента отходов кучи.

--

`G1 GC` уменьшает фрагментацию кучи за счет инкрементного параллельного копирования живых объектов из одного или нескольких `sets of regions (called Collection Sets (CSet)s)` в один или несколько различных новых областей для достижения сжатия.

Цель состоит в том, чтобы освободить как можно больше пространства кучи, начиная с тех регионов, которые содержат наиболее пригодное для восстановления пространство, при этом пытаясь не превысить цель времени паузы (`garbage first`).

--

G1 GC использует независимые `Remembered Sets (RSets)` для отслеживания ссылок на регионы.

Независимые RSet обеспечивают параллельный и независимый сбор областей, потому что только RSet региона должен сканироваться на наличие ссылок в этот регион, а не на всю кучу.

G1 GC использует `post-write barrier` для записи изменений в кучу и обновления RSets.



## Garbage Collection Phases

Помимо `evacuation pauses` (`see the section Allocation (Evacuation) Failure in Garbage-First Garbage Collector`), которые создают `stop-the-world (STW)`  `young and mixed garbage collections`, G1 GC также имеет `parallel, concurrent, and multiphase marking cycles`. 

G1 GC использует алгоритм ` snapshot-at-the-beginning (SATB) `, который логически делает снимок набора живых объектов в куче в начале `marking cycle`.

В набор живых объектов также входят объекты, `allocated` после  `marking cycle`.

Алгоритм маркировки GC G1 использует `pre-write barrier` для записи и маркировки объектов, которые являются частью логического снимка.



## Young Garbage Collections

G1 GC удовлетворяет большинству запросов `allocation` от добавления регионов до разделения `eden` на части.

Во время `young garbage collection` G1 GC собирает как регионы `eden`, так и регионы `survivor` из предыдущей сборки мусора.

Живые объекты из регионов `eden` и `survivor` копируются или эвакуируются в новый набор регионов.

Область назначения для конкретного объекта зависит от возраста объекта; объект, который достаточно стар, эвакуируется в регион старого поколения (то есть продвигается); в противном случае объект эвакуируется в `survivor` область и будет включен в `CSet` следующей `young or mixed ` сборки мусора.



## Mixed Garbage Collections

После успешного завершения `concurrent marking cycle,` G1 GC переключается с выполнения молодых сборок мусора на выполнение смешанных сборок мусора.

В смешанной сборке мусора G1 GC при необходимости добавляет несколько старых областей к набору областей `eden` и `survivor`, которые будут собраны.

Точное количество добавленных старых областей контролируется рядом флагов (`see "Taming Mixed Garbage Collectors" in the section Recommendations`).

После того, как G1 GC собирает достаточное количество старых областей (`over multiple mixed garbage collections`), G1 возвращается к выполнению молодых сборок мусора до завершения следующего цикла маркировки.



# Important Defaults

G1 GC - это адаптивный сборщик мусора со значениями по умолчанию, которые позволяют ему работать эффективно без изменений.

Table 10-1, "Default Values of Important Options for G1 Garbage Collector" , содержит список важных опций и их значений по умолчанию в Java HotSpot VM, сборка 24.

Вы можете адаптировать и настроить G1 GC в соответствии с требованиями производительности вашего приложения, введя параметры в Table 10-1, "Default Values of Important Options for G1 Garbage Collector" с измененными настройками в командной строке JVM.



Table 10-1 Default Values of Important Options for G1 Garbage Collector

| Option and Default Value               | Option                                                       |
| -------------------------------------- | ------------------------------------------------------------ |
| -XX:G1HeapRegionSize=``n               | Устанавливает размер области G1. Значение будет иметь степень двойки и может варьироваться от 1 МБ до 32 МБ. Цель состоит в том, чтобы иметь около 2048 регионов на основе минимального размера кучи Java. |
| -XX:MaxGCPauseMillis=200               | Устанавливает целевое значение для желаемого максимального времени паузы. Значение по умолчанию составляет 200 миллисекунд. Указанное значение не адаптируется к вашему размеру кучи. |
| -XX:G1NewSizePercent=5                 | Устанавливает процент кучи для использования в качестве минимального размера для молодого поколения. Значение по умолчанию составляет 5 процентов от вашей кучи Java.Foot1 Это экспериментальный флаг. См. Как разблокировать экспериментальные флаги ВМ для примера. Этот параметр заменяет параметр -XX: DefaultMinNewGenPercent. |
| -XX:G1MaxNewSizePercent=60             | Устанавливает процент от размера кучи, который будет использоваться как максимальный размер для молодого поколения. Значение по умолчанию составляет 60 процентов вашей кучи Java.Footref1 Это экспериментальный флаг. См. Как разблокировать экспериментальные флаги ВМ для примера. Этот параметр заменяет параметр -XX: DefaultMaxNewGenPercent. |
| -XX:ParallelGCThreads=``n              | Устанавливает значение рабочих потоков STW. Устанавливает значение n в число логических процессоров. Значение n совпадает с числом логических процессоров до значения 8.  Если имеется более восьми логических процессоров, установите значение n равным приблизительно 5/8 логических процессоров. Это работает в большинстве случаев, за исключением больших систем SPARC, где значение n может составлять примерно 5/16 от логических процессоров. |
| -XX:ConcGCThreads=``n                  | Устанавливает количество `parallel marking threads`. Устанавливает n равным приблизительно 1/4 от числа параллельных потоков сборки мусора (ParallelGCThreads). |
| -XX:InitiatingHeapOccupancyPercent=45  | Устанавливает порог занятости кучи Java, который запускает цикл маркировки. Занятость по умолчанию составляет 45 процентов всей кучи Java. |
| -XX:G1MixedGCLiveThresholdPercent=85   | Устанавливает порог занятости для старого региона, который будет включен в цикл смешанного сбора мусора. Заполняемость по умолчанию составляет 85 процентов.  Это экспериментальный флаг. См. Как разблокировать экспериментальные флаги ВМ для примера. Этот параметр заменяет параметр -XX: G1OldCSetRegionLiveThresholdPercent. |
| -XX:G1HeapWastePercent=5               | Устанавливает процент кучи, которую вы готовы тратить. Виртуальная машина Java HotSpot не запускает цикл смешанного сбора мусора, когда процент извлечения меньше, чем процент кучи отходов. Значение по умолчанию составляет 5 процентов. |
| -XX:G1MixedGCCountTarget=8             | Устанавливает целевое число смешанных сборок мусора после цикла маркировки для сбора старых областей с не более чем G1MixedGCLIveThresholdPercent живых данных. По умолчанию используется 8 смешанных сборок мусора. Цель для смешанных коллекций - быть в пределах этого целевого числа.Footref1 |
| -XX:G1OldCSetRegionThresholdPercent=10 | Устанавливает верхний предел на количество старых областей, которые будут собираться во время смешанного цикла сбора мусора. Значение по умолчанию составляет 10 процентов от кучи Java.Footref1 |
| -XX:G1ReservePercent=10                | Устанавливает процентную долю резервной памяти, которая остается свободной, чтобы снизить риск переполнения пространства. По умолчанию это 10 процентов. Когда вы увеличиваете или уменьшаете процент, не забудьте откорректировать общую кучу Java на ту же сумму. |

Этот параметр недоступен в Java HotSpot VM build 23 или более ранней версии.



## How to Unlock Experimental VM Flags

Чтобы изменить значение экспериментальных флагов, вы должны сначала разблокировать их. Вы можете сделать это, установив -XX: + UnlockExperimentalVMOptions явно в командной строке перед любыми экспериментальными флагами. Например:

````java
java -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=10 -XX:G1MaxNewSizePercent=75 G1test.jar
````



## Recommendations

Когда вы оцениваете и настраиваете G1 GC, помните о следующих рекомендациях:

- **Young Generation Size**: Избегайте явной установки размера молодого поколения с помощью опции `-Xmn` или любой другой или другой связанной опции, такой как` -XX: NewRatio`. Фиксирование размера молодого поколения пересиливает цель цели времени паузы.

- **Pause Time Goals**: Когда вы оцениваете или настраиваете сборку мусора, всегда есть компромисс между задержкой и пропускной способностью.

  G1 GC - это инкрементный сборщик мусора с равномерными паузами, но также с большими накладными расходами в потоках приложения. 

  Цель пропускной способности для G1 GC - 90% времени приложения и 10% времени сбора мусора.  

  Сравните это с параллельным коллектором Java HotSpot VM.	

  Цель пропускной способности `parallel collector` - 99% времени приложения и 1% времени сборки мусора. 

  Поэтому, когда вы оцениваете G1 GC для пропускной способности, ослабьте целевое время паузы.

  Установка слишком агрессивной цели означает, что вы готовы нести увеличение накладных расходов на сборку мусора, что напрямую влияет на пропускную способность.

  Когда вы оцениваете G1 GC на время ожидания, вы устанавливаете желаемую (мягкую) цель в реальном времени, и G1 GC будет пытаться ее достичь. 

  Как побочный эффект, пропускная способность может пострадать.

  See the section [Pause Time Goal](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#pause_time_goal) in [Garbage-First Garbage Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection) for additional information.

- `Taming Mixed Garbage Collections`:  Поэкспериментируйте со следующими параметрами при настройке смешанных сборок мусора.

  See the section [Important Defaults](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#important_defaults) for information about these options:

  - `-XX:InitiatingHeapOccupancyPercent`: Use to change the marking threshold.
  - `-XX:G1MixedGCLiveThresholdPercent` and `-XX:G1HeapWastePercent`: Use to change the mixed garbage collection decisions.
  - `-XX:G1MixedGCCountTarget` and `-XX:G1OldCSetRegionThresholdPercent`: Use to adjust the CSet for old regions.



## Overflow and Exhausted Log Messages

Когда вы видите `to-space overflow or to-space exhausted messages` в журналах, у G1 GC недостаточно памяти для`survivor or promoted` объектов, или для обоих.

Куча Java не может, потому что она уже на максимуме.

Пример сообщения:

````bash
924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space exhausted), 0.1957310 secs]

924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space overflow), 0.1957310 secs]
````

Чтобы облегчить проблему, попробуйте следующие корректировки:

- Increase the value of the `-XX:G1ReservePercent` option (and the total heap accordingly) to increase the amount of reserve memory for "to-space".
- Start the marking cycle earlier by reducing the value of `-XX:InitiatingHeapOccupancyPercent.`
- Increase the value of the `-XX:ConcGCThreads` option to increase the number of parallel marking threads.

See the section [Important Defaults](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#important_defaults) for a description of these options.



## Humongous Objects and Humongous Allocations

Для G1 GC любой объект, размер которого больше половины, считается огромным объектом.

Такой объект `allocated directly`  в `old generation` в `humongous regions`.

Эти огромные регионы являются `contiguous set of regions`. `StartsHumongous` отмечает начало непрерывного набора, а `ContinuesHumongous` отмечает продолжение набора.

--

Перед выделением какой-либо огромной области проверяется `marking threshold`, при необходимости запускается `concurrent cycle`.

Мертвые огромные объекты освобождаются в конце цикла маркировки на этапе очистки, а также во время полного цикла сбора мусора.

Чтобы уменьшить затраты на копирование, огромные объекты не включаются ни в одну `evacuation pause`. 

Полный цикл сбора мусора уплотняет огромные объекты на месте.

--

Поскольку каждый отдельный набор областей StartsHumongous и ContinuesHumongous содержит только один огромный объект, пространство между концом огромного объекта и концом последней области, охватываемой объектом, не используется.

Для объектов, которые немного превышают размер регионов в куче, это неиспользуемое пространство может привести к фрагментации кучи.

Если вы видите `back-to-back concurrent cycles`, инициированные из-за огромных `allocations `, и если такие `allocations ` фрагментируют ваше `old generation`, то увеличьте значение -XX: G1HeapRegionSize так, чтобы предыдущие огромные объекты больше не были громоздкими и следовали `regular allocation path`. 



# 11 Other Considerations

В этом разделе рассматриваются другие ситуации, которые влияют на сборку мусора.



## Finalization and Weak, Soft, and Phantom References

Некоторые приложения взаимодействуют со сборкой мусора с помощью финализации и слабых, мягких или фантомных ссылок.

Эти функции могут создавать производительные артефакты на уровне языка программирования Java.

Примером этого является `relying on finalization` для закрытия файловых дескрипторов, что делает внешний ресурс (дескрипторы) зависимым от `promptness` сбора мусора.

Полагаться на сборку мусора для управления ресурсами, отличными от памяти, почти всегда плохая идея.

The section [Related Documents](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/preface.html#gct_related) in the [Preface](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/preface.html#CHDBHEGA) includes an article that discusses in depth some of the pitfalls of finalization and techniques for avoiding them.



## Explicit Garbage Collection

Другой способ, с помощью которого приложения могут взаимодействовать со сборщиком мусора, - это явный вызов полной сборки мусора с помощью вызова System.gc ().

Это может заставить `major collection` выполняться, когда в этом нет необходимости (например, когда достаточно `minor collection`), и поэтому в целом следует избегать.

Влияние производительности явных сборщиков мусора можно измерить, отключив их с помощью флага -XX: + DisableExplicitGC, который заставляет виртуальную машину игнорировать вызовы System.gc ().

--

Одно из наиболее часто встречающихся применений явной сборки мусора происходит с распределенной сборкой мусора `distributed garbage collection (DGC)` удаленного вызова метода `of Remote Method Invocation (RMI)`.

Приложения, использующие RMI, ссылаются на объекты в других виртуальных машинах. Мусор не может быть собран в этих распределенных приложениях без периодического вызова сборки мусора из локальной кучи, поэтому RMI периодически выполняет полные сборы.

Частота этих коллекций может контролироваться с помощью свойств, как в следующем примере:

````
java -Dsun.rmi.dgc.client.gcInterval=3600000
    -Dsun.rmi.dgc.server.gcInterval=3600000 ...
````

В этом примере указывается явная сборка мусора один раз в час вместо скорости по умолчанию один раз в минуту.

Однако это также может привести к тому, что некоторым объектам потребуется гораздо больше времени для восстановления.

Эти свойства могут быть установлены на Long.MAX_VALUE, чтобы сделать время между явными `collections ` фактически бесконечным, если не требуется верхняя граница `timeliness ` для DGC.



## Soft References

Мягкие ссылки дольше сохраняются в виртуальной машине сервера, чем в клиенте.

Скорость очистки можно контролировать с помощью параметра командной строки -XX: SoftRefLRUPolicyMSPerMB = <N>, который указывает количество миллисекунд (мс), в течение которых мягкая ссылка будет оставаться активной (после того, как она станет недостижимой) для каждого мегабайта. свободного места в куче.

Значение по умолчанию составляет 1000 мс на мегабайт, что означает, что мягкая ссылка будет сохраняться (после того, как будет собрана последняя сильная ссылка на объект) в течение 1 секунды на каждый мегабайт свободного пространства в куче.

Это приблизительный показатель, потому что мягкие ссылки очищаются только во время сборки мусора, что может происходить время от времени



## Class Metadata

Классы Java имеют внутреннее представление в Java Hotspot VM и называются `class metadata`.

В предыдущих выпусках Java Hotspot VM ` class metadata` выделялись в так называемой `permanent generation`.

В JDK 8 `permanent generation` было удалено, а `class metadata` размещены в `native memory`.

Объем ` native memory`, которую можно использовать для `class metadata`, по умолчанию не ограничен.

Используйте опцию `MaxMetaspaceSize` `native memory`, используемой для `class metadata`.

--

Java Hotspot VM явно управляет пространством, используемым для `metadata`.

Пространство запрашивается из ОС, а затем делится на куски (`chunks`).

Загрузчик классов выделяет пространство для `metadata ` из своих `chunks ` (`chunk ` привязан к определенному загрузчику классов).

Когда классы выгружаются для загрузчика классов, его фрагменты повторно используются или возвращаются в ОС.

`Metadata ` используют пространство, выделенное `mmap`, а не `malloc`.

--

Если `UseCompressedOops` включен и `UseCompressedClassesPointers` используется, то для метаданных класса используются две логически разные области `native memory`.

UseCompressedClassPointers использует 32-битное смещение для представления указателя класса в 64-битном процессе, как и UseCompressedOops для ссылок на объекты Java.

Регион выделяется для этих сжатых указателей классов (32-битные смещения).

Размер области может быть установлен с помощью CompressedClassSpaceSize и составляет 1 гигабайт (ГБ) по умолчанию.

Пространство для сжатых указателей классов зарезервировано как пространство, выделенное mmap при инициализации и зафиксированное по мере необходимости.

`MaxMetaspaceSize` применяется к сумме зафиксированного сжатого пространства классов и пространства для метаданных другого класса.

--

`Class metadata` освобождаются, когда соответствующий класс Java выгружается.

Java-классы выгружаются в результате сборки мусора, и сборка мусора может быть вызвана для выгрузки классов и освобождения метаданных класса.

Когда пространство, выделенное для метаданных класса, достигает определенного уровня (`(a high-water mark`), инициируется сборка мусора.

После сборки мусора `high-water mark` может быть повышена или понижена в зависимости от количества места, освобожденного от метаданных класса.

`The high-water mark` будет повышена, чтобы не вызывать очередной сбор мусора слишком рано.

`The high-water mark` изначально установлена на значение параметра командной строки `MetaspaceSize`.

Он повышается или понижается в зависимости от параметров MaxMetaspaceFreeRatio и MinMetaspaceFreeRatio.

Если выделенное пространство, доступное для метаданных класса в процентах от общего выделенного пространства для метаданных класса, больше, чем MaxMetaspaceFreeRatio, то верхняя отметка будет понижена.

Если оно меньше, чем MinMetaspaceFreeRatio, то верхняя отметка будет повышена.

--

Укажите более высокое значение для параметра MetaspaceSize, чтобы избежать ранних сборок мусора, вызванных для метаданных класса.

Количество метаданных класса, выделенных для приложения, зависит от приложения, и общие рекомендации по выбору MetaspaceSize отсутствуют.

Размер по умолчанию MetaspaceSize зависит от платформы и составляет от 12 до 20 МБ.

Information about the space used for metadata is included in a printout of the heap. A typical output is shown in [Example 11-1, "Typical Heap Printout"](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html#typical_heap_printout).

Example 11-1 Typical Heap Printout

````bash
Heap
  PSYoungGen      total 10752K, used 4419K
    [0xffffffff6ac00000, 0xffffffff6b800000, 0xffffffff6b800000)
    eden space 9216K, 47% used
      [0xffffffff6ac00000,0xffffffff6b050d68,0xffffffff6b500000)
    from space 1536K, 0% used
      [0xffffffff6b680000,0xffffffff6b680000,0xffffffff6b800000)
    to   space 1536K, 0% used
      [0xffffffff6b500000,0xffffffff6b500000,0xffffffff6b680000)
  ParOldGen       total 20480K, used 20011K
      [0xffffffff69800000, 0xffffffff6ac00000, 0xffffffff6ac00000)
    object space 20480K, 97% used 
      [0xffffffff69800000,0xffffffff6ab8add8,0xffffffff6ac00000)
  Metaspace       used 2425K, capacity 4498K, committed 4864K, reserved 1056768K
    class space   used 262K, capacity 386K, committed 512K, reserved 1048576K
````

В строке, начинающейся с Metaspace, `used` - это объем пространства, используемого для загруженных классов.

`capacity` - это пространство, доступное для метаданных в выделенных в настоящее время `chunks`.

`committed` - это количество места, доступного для `chunks`.

`reserved` - это количество места, зарезервированного (но не обязательно выделенного) для метаданных.

Строка, начинающаяся с `class space`, содержит соответствующие значения для метаданных для `compressed class pointers`.



# NOTES

1. Определение размера одного поколения не влияет на частоту сбора и время паузы для другого поколения.
2. The Java HotSpot VM triggers the marking phase when the total Java heap occupancy exceeds the default threshold. See the sections [Concurrent Mark Sweep (CMS) Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector) and [Garbage-First Garbage Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection).



# Вопросы

- Когда выбор `GC` имеет значение?
  - For some applications, the answer is never. That is, the application can perform well in the presence of garbage collection with pauses of modest frequency and duration. However, this is not the case for a large class of applications, particularly those with large amounts of data (multiple gigabytes), many threads, and high transaction rates.
- Как звучит закон Амдала?
  - Amdahl's law (parallel speedup in a given problem is limited by the sequential portion of the problem) implies that most workloads cannot be perfectly parallelized; some portion is always sequential and does not benefit from parallelism.
- Как влияет сборка мусора на потерю пропускной способности на малых и больших системах? И почему?
- "Если сборка мусора занимает 1% времени на однопроцессорной машине. То это приведет к 20% потери пропускной способности при 32 процессорах". Почему так происходит?
  - Связано с законом Амдала, то в идеальных условиях можно ускороить программу в n раз, где n - это количество процессоров. Но каждая задача имеет не параллезируюмую работы (сборка мусора), это снижает потенциальную пропускную способность.
- Когда стоит и не стоит использовать `Serial collector`?
- Когда `Serial collector` выбирается по умолчанию?
- Какой самый простой способ отчистить мусора?
- Почему он не подходит?
- System.gc приравнивается к Concurrent Mode Failure для CMS?
- На какой аксиопер построена сборка мусора с использованием поколений?
- Какой сборщик мусора работает по умолчанию?
- Чем различаются `generations` для разных `GC`?
- Сколько раз объекты копируются из `Survivor`?
- Как `GC` решает, что нужно кинуть `OutOfMemoryError`? 
- Можно ли отключить `OutOfMemoryError`?
- Можно ли динамически увеличить память после `OutOfMemoryError`?
- HotSpot VM Frequently Asked Questions (FAQ) -> https://www.oracle.com/technetwork/java/hotspotfaq-138619.html



# Источники

1. [Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)
2. [Java HotSpot Garbage Collection](https://www.oracle.com/technetwork/java/javase/tech/index-jsp-140228.html)
3. [Open JDK - Storage Management](http://openjdk.java.net/groups/hotspot/docs/StorageManagement.html)
4. Richard Jones and Rafael Lins, *Garbage Collection: Algorithms for Automated Dynamic Memory Management*, Wiley and Sons (1996), ISBN 0-471-94148-4

