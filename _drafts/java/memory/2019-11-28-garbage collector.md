---
layout: post
title: "Garbage collector"
date: 2019-11-30 21:00:00 +0300
categories: jvm
permalink: garbage-collector
---

# Сбор мусора (`Garbage collector`) в `JVM HotSpot `

Сборщик мусора (``Garbage collector - GC`) - это инструмент управления памятью, который

- **выделяет память** для новых объектов и помещает их в `young generation`,
- **перемещает живые объекты** в `old generation`,
- **ищет живые объекты** в `generations`, используя параллельные стратегии маркировки,
- **восстанавливает память**, удаляя и сжимая объекты, используя параллельное копирование.



# Теория сборки мусора

## Закон Амдала и потеря пропускной способности

Закон Амдала (ускорение с помощью параллельного вычисления ограничено размером последовательной части программы) подразумевает что часть рабочих нагрузок не может быть распараллелена и выполняется всегда последовательно (работы при сборке мусора).

Математическое выражение закона Амдала, выглядит следующим образом, где

- `Sp` - возможно ускорение в количество раз,
- `a` - непараллезируемая часть работ, 
- `p` - количество процессоров.

![S_{p}={\cfrac  {1}{\alpha +{\cfrac  {1-\alpha }{p}}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3d6be545af375c8517c584f7d0364b75892979a3)

Например, в идельной системе (`a` = 0) ускорение пропроционально количеству процессоров, например при `p` = 32, ускорение будет в 32 раза.

Если сборка мусора занимает 1% времени на однопроцессорной машине. То это приведет к потери пропускной способности более чем на 20% (23,6%) на 32ух процессорах.

Если сборка мусора занимает 10% времени (что не считается очень большим значением для однопроцессорных систем), то это приведет к более чем 75% (75,6%) потери пропускной способности на 32ух процессорах.

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_005_gph_pc_vs_tp.png)

То есть незначительные проблемы пропускной способности, могут привести к большим проблемам (`bottleneck`) при масштабировании. С другой стороны, небольшие улучшения могут дать большой скачок в производительности. Поэтому для больших систем, целесообразно выбрать правильных `GC` и настроить его.



## Что такое мусор?

Объект считается мусором, когда на него нет ссылок в работающей программе.



## Наивный алгоритм

Оставить все объекты, которые доступны из работающей программы. Все остальные объекты удалить, так как это мусор.

### Неприемлемая производительность

Время работы алгоритма пропорционально количеству живых объектов, что неприемлемо для больших приложений, поддерживающих большое количество живых объектов.

### Как сделать производительность приемлемой?

В `JVM HotSpot` используются различные алгоритмы, но базовый принцип основан на гипотезе слабого поколения (`weak generational hypothesis`).



## Гипотеза слабого поколения (`Weak generational hypothesis`)

Гипотеза слабого поколения (`Weak generational hypothesis`) гласит "большинство объектов умрут молодыми".

Голубая область показывает типичное распределение времени жизни объектов.

- Ось X - это время жизни объекта, измеренное в байтах. 
- Ось Y - это общее количество байтов для объектов с соответствующим временем жизни.



![Типичное распределение времени жизни объектов](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_003_alc_vs_srvng.png)

- Острый пик слева представляет объекты, которые «умерли» вскоре после распределения. Например, объекты-итераторы часто работают в течение одного цикла.
- Некоторые объекты живут дольше, и поэтому распределение простирается вправо. Обычно объекты, выделенные при инициализации живут до завершения процесса.
- Между этими двумя крайностями находятся объекты, которые живут в течение некоторого промежуточного вычисления, рассматриваемого здесь как холм справа от левого пика.

> Некоторые приложения имеют другие формы распределения, но удивительно, что большинство обладает этой общей формой.

### Производительность

Время сбора мусора также пропорциональна количеству живых объектов. Однако так как области в `young generation` небольшие и полны мертвых объектов, то сбор мусора выполняется очень быстро. То есть эффективный сбор мусора возможен благодаря тому, что большинство объектов «умирают молодыми».

Как правило, некоторая часть выживших объектов из `young generation` перемещается в `ternted generarion` и так формируется основная куча. Сбор мусора в которой происходит дольше, так как объектов больше.



## Поколения (`Generations `)

В `JVM HotSpot` память разделяется на пулы, содержащие объекты разного возраста. Такие пулы называются "поколениями" (`generations`, `generational collection`).

Вся память `JVM` разделена на

- молодое поколение `young generation`, содержит
  - `Eden`,
  - `Survivor` (2е области), 
  - `Virtual`;
- штатное поколение `tenured geneartion`, содержит
  - основная куча,
  - `Virtual`.

>  Штатное поколение можно называть также старым (`old generation`).

**Схема поколений, за исключением `parallel collector` и `G1`**

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_001_armgnt_gn.png)

`Virtual` - область, которая резервируется при инициализации, но память не выделяется физически.

### Как объекты двигаются по поколениям?

- Когда поколение заполняется, сборка мусора происходит только в нем; мусор в других поколениях не собирается.
- Большинство объектов изначально располагаются в `Eden`.
- Одно пространство `Survivor` всегда пустое. Другое служит для хранения выживших объектов из `Eden`. Если `Survivor` заполняется, то живые объекты копируются в пустой `Survivor`, а заполненный отчищается.
- Таким образом, объекты копируются между `Survivor` до тех пор, пока не станут достаточно взрослыми, чтобы их можно было переместить `tenured generation`.



# Доступные сборщики

Дискуссия на этот счет была о серийном коллекционере. Java HotSpot VM включает в себя три различных типа сборщиков, каждый с различными характеристиками производительности

















# Настройка `GC`

## Эргономика

Эргономика - это процесс настройки `JVM` и `GC` с целью использовать оптимальный режим работы:

- повысить пропускную способность,
- уменьшить время пауз (отклика),
- уменьшить количество используемых ресурсов.



## Дефолтный выбор

`JVM` предоставляет платформо-зависимый автоматический выбор:

- сборщика мусора (`GC`),
- размера `heap`,
- компилятора времени выполения (`runtime compiler`).

Дефолтный выбор соответствует нуждам различных приложений и требует минимальной настройки через командную строку.

Для автоматического выбора значений `JVM` оперделяет операционную систему и параметры машины.

### Класс "Сервер" (`Server-class machine`) 

**TODO only 32-bit**

Машина определяется в класс `Server-class machine`, если имеет

- 2 или более физических процессоров,
- 2 или болee GB оперативной памяти.

Для `Server-class machine` по дефолту выбирается:

- `Throughput garbage collector`,
- Начальных хип (`Min heap`) = 1/64 оперативной памяти до 1GB,
- Максимальный хип (`Max heap`)  = 1/4 оперативной памяти до 1GB,
- Серверный компилятор времени выполнения (`Server runtime compiler`)





## Настройка на основе поведения (`Behavior-Based Tuning`)

Эргономика `JVM` предоставляет возможность автоматической динамической настройки `JMV` и `GC` на основе поведения приложения (`behavior-based tuning`). 



В добавок, настройка на основе поведения (`behavior-based tuning`) динамически настраивает размер `Heap` под приложение.



Используйте дефолтные настройки прежде чем использовать более детальные настройки.



# Behavior-Based Tuning

`Java SE` два параметра настройки сборки мусора, которые основаны на достижении определенного поведения приложения: 

- цель максимального времени паузы,
- цель пропускной способности приложения.

Эти два параметра недоступны в других сборщиках. Обратите внимание, что такое поведение не всегда может быть достижимо. Приложению требуется куча, достаточно большая, чтобы хотя бы хранить все оперативные данные. Кроме того, минимальный размер кучи может помешать достижению этих желаемых целей.



## Цель, максимальное время паузы

Время паузы - это продолжительность, в течение которой сборщик мусора останавливает приложение и восстанавливает пространство, которое больше не используется. Цель максимального времени паузы состоит в том, чтобы ограничить самый длинный из этих пауз. Среднее время для пауз и дисперсии в среднем поддерживается сборщиком мусора. Среднее значение берется с начала выполнения, но взвешивается таким образом, чтобы более поздние паузы учитывались в большей степени. Если среднее значение плюс дисперсия времени паузы превышает максимальное значение времени паузы, то сборщик мусора считает, что цель не достигнута.

Максимальное время паузы указывается с помощью параметра командной строки `XX:MaxGCPauseMillis=<nnn>`. Это интерпретируется как подсказка сборщику мусора о желаемом времени паузы `<nnn>` миллисекунд. Сборщик мусора будет корректировать размер кучи Java и другие параметры, связанные со сборкой мусора, чтобы сделать паузы сбора мусора короче, чем `<nnn>` миллисекунд. По умолчанию нет максимальной цели времени паузы. Эти корректировки могут привести к более частому запуску сборщика мусора, что приведет к снижению общей пропускной способности приложения. Сборщик мусора пытается достичь цели времени паузы, а после цели пропускной способности. В некоторых случаях, однако, желаемая цель времени паузы не может быть достигнута.



## Цель, максимальная пропускная способность

Цель пропускной способности измеряется с точки зрения времени, затраченного на сбор мусора, и времени, потраченного за пределами сбора мусора (называемого временем приложения). Цель задается параметром командной строки `-XX: GCTimeRatio = <nnn>`. Отношение времени сборки мусора к времени приложения составляет `1 / (1 + <nnn>)`. Например, `-XX: GCTimeRatio = 19` устанавливает цель в `1/20` или 5% от общего времени для сбора мусора.

Время, затрачиваемое на сборку мусора - это общее время для сборок как молодого, так и старого поколений. Если цель пропускной способности не достигается, размеры поколений увеличиваются, чтобы увеличить время, в течение которого приложение может выполняться между коллекциями



## Цель, отпечаток

Если были достигнуты цели пропускной способности и максимального времени паузы, то сборщик мусора уменьшает размер кучи до тех пор, пока не будет достигнута одна из целей (без исключения цели пропускной способности). Цель, которая не достигнута, затем решается.



# Стратегия настройки (`Tuning Strategy`)

Не выбирайте максимальное значение для кучи, если вы не знаете, что вам нужна куча, превышающая максимальный размер кучи по умолчанию. Выберите целевую пропускную способность, достаточную для вашего приложения.

Куча будет расти или уменьшаться до размера, который будет поддерживать выбранную цель пропускной способности. Изменение в поведении приложения может привести к увеличению или уменьшению кучи. Например, если приложение начинает выделять с более высокой скоростью, куча будет расти, чтобы поддерживать ту же пропускную способность.

Если размер кучи увеличивается до максимального размера, а цель пропускной способности не достигается, максимальный размер кучи слишком мал для цели пропускной способности. Установите для максимального размера кучи значение, близкое к общему объему физической памяти на платформе, но не вызывающее перестановки приложения. Запустите приложение еще раз. Если цель по пропускной способности все еще не достигнута, тогда цель для времени приложения слишком высока для доступной памяти на платформе.

Если цель пропускной способности может быть достигнута, но есть паузы, которые являются слишком длинными, то выберите максимальную цель времени паузы. Выбор цели максимального времени паузы может означать, что ваша цель по пропускной способности не будет достигнута, поэтому выберите значения, которые являются приемлемым компромиссом для приложения.

Типично, что размер кучи будет колебаться, поскольку сборщик мусора пытается удовлетворить конкурирующие цели. Это верно, даже если приложение достигло устойчивого состояния. Давление для достижения цели по пропускной способности (которая может потребовать большей кучи) конкурирует с целями за максимальное время паузы и минимальную занимаемую площадь (что может потребовать небольшой кучи).





## The parallel collector

Ситуация когда `Serial collector` не является лучшим выбором, это большое многопоточное приложение, которое выполняется на машине с большим количеством памяти и двумя и более процессорами. Когда приложение запущено на такой машине, то параллельный сборщик (`parallel collector`) выбирается по умолчанию.





# Последовательный сборщик (`Serial collector`)

Последовательный сборщик (`Serial collector`) обычно подходит для небольших приложений на однопроцессорных машинах с размером `heap` примерно до 100MB. 

**TODO**

Использование параллельных коллекторов не рекомендуется в таких условиях, так как они имеют дополнительные накладные расходы и сложность, что является ценой за специализированное поведени.





# Параллельный сборщик (`The Parallel Collector` or `The Throughput Collector`)

Параллельный сборщик (`The Parallel Collector` or `The Throughput Collector`) работает также как и последовательный сборщик, основное отличие в том, что для ускорения сбора мусора используется несколько потоков.

Параллельный сборщик включается так:

````bash
java -XX:+UseParallelGC -Xmx2g -Xms32m -jar app.jar 10
````

По умолчанию, при использовании этой опции, сборка мусора выполняется параллельно во всех поколениях.

- Параллельный сборщик выбран по умолчанию на машинах серверного класса.



## Сколько ядер используется?

- На машинах с 8 ядрами и более, параллельный сборщик использует 5/8 ресурсов,
- на машинах с менее 8 ядрами, доля уменьшается до 5/16,
- можно настроить конкретное число потоков с помощью команды`-XX: ParallelGCThreads = <N>`.



## Параллельный сборщик VS Последовательный сборщик

- **Ядер = 1**. На машине с одним ядром параллельный сборщик, не будет работать также хорошо как и последовательный сборщик, из-за накладных расходов (синхронизации и тд).

- **Ядер = 2**. На двух ядрах параллельный сборщик обычно превосходит последовательный на скромную велечину.

- **Ядер > 2**. Кода доступно более двух ядер паралелльный сборщик обычно значительно лучше, чем последовательный.

  

## Эффект фрагментации

- Для обеспечения хорошей производительности при использовании последовательного или параллельного сборщика **размер `Heap`'а не отличается**.

- Включение параллельного сборщика должно сделать паузы сбора короче.

- А также при использовании параллельного-сборщика может наблюдаться эффект фрагментации. Когда несколько потоков обрабатывают `young generation` и передвигают объекты в `tenured generation`, потоки резервируют части памяти (`"promotion buffers"`) в `ternured generation`, данный процесс может стать причиной фрагментации. 

  - Уменьшение количества потоков сборки мусора и увеличение размера `tenured generation` уменьшит эффект фрагментации.

  

## Поколения (`Generations`)

![](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img/jsgct_dt_002_armgnt_gn_pl.png)



## Эргономика параллельного сборщика (`Parallel Collector Ergonomics`)

- Кроме того, в параллельном коллекторе используется метод автоматической настройки, который позовляет выбирать специализированное поведение, вместо низко-уровневной настройки.
- Вы можете указать максимальное время приостановки сбора мусора, пропускную способность и площадь (размер кучи).

- **Максимальная пауза GC**
  - По умолчанию нет максимальной времени паузы,
  - чтобы указать, используется команда `-XX:MaxGCPauseMillis=<N>`.
  - Команда интерпретируется как подсказка, что желательное времени паузы должно быть меньше чем `N` милисекунд.
  - Если задана "максимальная пауза", тогда размер `heap` и другие параметра, коректируются, чтобы достичь цели. Эти корректировки могут привести к уменьшению общей пропускной способности приложения и желаемая цель также может быть не достигнута.

- **Пропускная способность (`Throughput`) **
  - Цель пропускной способности измеряется с точки зрения времени, потраченного на сборку мусора, по сравнению с временем, потраченным вне сбора мусора (называемое временем приложения).
  - Цель задается параметром командной строки `-XX: GCTimeRatio = <N>`, который устанавливает отношение времени сборки мусора к времени приложения в `1 / (1 + <N>)`.
- **Footprint**
  - Максимальный размер кучи указывается с помощью опции `-Xmx <N>`. Кроме того, сборщик имеет неявную цель минимизировать размер кучи, пока выполняются другие цели.



## Приоритеты целей

Цели решаются в следующем порядке:

- Максимальное время паузы

- Пропускная способность

- Минимальная цель следа

Максимальное время паузы достигается первым. Только после того, как это достигнуто, цель пропускной способности адресована. Точно так же, только после того, как первые две цели были достигнуты, рассматривается цель следа.



## Корректировка `Generations`

- Статистика средней времени паузы обновляется каждый раз после обработки каждой коллекций `generations`.
- Затем выполняются тесты для определения того, были ли достигнуты цели и вносятся необходимые корректировки в размер `generations`.
- Исключение, то есть статистика не собирается, при явных вызовах сборщика мусора (`Systems.gc()`).



## Увеличение и уменьшение размера `generations` 

- Увеличение и уменьшение размера `generation` измеряется в процентах от размера поколения.
- Рост и сжатие осуществляется с разными величинами.
- По умолчанию `generations` увеличивается на 20%, а уменьшается на 5%.
- Для `young generation` процесс роста задаётся командой `-XX: YoungGenerationSizeIncrement = <Y>`
- Для `turned generation` - `-XX: TenuredGenerationSizeIncrement = <T>`
- Процент сжатия настраивается командой `-XX: AdaptiveSizeDecrementScaleFactor = <D>`, если прирост составляет `X` процентов, то уменьшение при сокращении составляет `X/D` процентов.
- При запуске приложения может добавляться дополнительный процент к увеличения `generation`, этот эффект не долгосрочный. Целью является повышения производительности при запуске.
- Если максимальное время паузы не достигается, тогда размер только одного поколения `generation` сокращается за раз. Если время паузы обоих поколений выше цели, то размер поколения с большим временем паузы сокращается первым.

- Если цель пропускной способности не достигается, размеры обоих поколений увеличиваются. Каждое поколение увеличивается пропорционально вкладу в общее время сбора мусора.  Например, если время сбора мусора молодого поколения составляет 25% от общего времени сбора, и если полный прирост поколений будет на 20%, то молодое поколение будет увеличено на 5%.



## Дефолтный размер `Heap` для `Client JVM`

- Если не указан начальный и максимальный размеры кучи через командную строку, значения рассчитываются на основе объема памяти на машине.
- Максимальный размер кучи, равен
  - 1/2 физической памяти, если на машине до 192MB;
    - Если на машине 128MB, то максимальный размер - 64MB.
  - 1/4 физической памяти (но не больше 1GB), если на машине больше 192MB.
    - Если на машине 1GB, то максимальный размер - 256MB.
- Минимальный размер кучи (`initial heap size`), равен
  - минимум 8MB или 1/64 физической памяти (но не больше 1GB).
- Максимальный размер `young generation` = 1/3 `heap`.



## Дефолтный размер `Heap` для `Server JVM`

- На `32-bit JVMs` может достигать 1GB, если на машине 4GB или больше.
- На `64-bit JVMs` может достигать 32GB, если на машине 128GB или больше.



## Указать  начальный и максимальный размер `heap`

- `-Xms` -  (initial heap size)

- `-Xmx` - (maximum heap size)

- Если вы знаете какой размер `heap` нужен для вашего приложения, можете установить `-Xms` и `-Xmx` в одно и то же значение. Если нет, `JVM` запустится с использованием начального размера кучи, а затем будет увеличивать кучу, пока не найдет баланс между использованием кучи и производительностью.

- Для проверки дефолтных значений используйте команду `-XX:+PrintFlagsFinal` .

  ````bash
  java -XX:+PrintFlagsFinal <GC options> -version | grep MaxHeapSize
  ````

  

## Excessive GC Time and OutOfMemoryError

Параллельный сборщик выдает ошибку OutOfMemoryError, если слишком много времени тратится на сборку мусора (GC):

- Если на сборку мусора уходит более 98% общего времени и восстанавливается менее 2% кучи, то генерируется ошибка OutOfMemoryError
- Эта функция предназначена для предотвращения длительного периода работы при ничтожном прогрессе, поскольку куча слишком мала.
- При необходимости эту функцию можно отключить, добавив параметр `-XX: -UseGCOverheadLimit`.















## Notes

1. The Java HotSpot VM triggers the marking phase when the total Java heap occupancy exceeds the default threshold. See the sections [Concurrent Mark Sweep (CMS) Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector) and [Garbage-First Garbage Collector](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection).

















## The garbage collector, heap size, and runtime compiler

The JVM provides platform-dependent default selections for the garbage collector, heap size, and runtime compiler.



## Maximum pause time goal and application throughput goal



## Maximum Pause Time Goal



## Throughput Goal



## Tuning Strategy

Do not choose a maximum value for the heap unless you know that you need a heap greater than the default maximum heap size. Choose a throughput goal that is sufficient for your application.



# Generations

## An object is considered garbage

An object is considered garbage when it can no longer be reached from any pointer in the running program.



## Most objects survive for only a short period of time

Efficient collection is made possible by focusing on the fact that a majority of objects "die young."



## The central tenet of this document:

If garbage collection becomes a bottleneck, you will most likely have to customize the total heap size as well as the sizes of the individual generations. Check the verbose garbage collector output and then explore the sensitivity of your individual performance metric to the garbage collector parameters.



## The young generation consists of eden and two survivor spaces

- The young generation consists of eden and two survivor spaces. 

- Most objects are initially allocated in eden. 

- One survivor space is empty at any time, and serves as the destination of any live objects in eden; the other survivor space is the destination during the next copying collection. 

- Objects are copied between survivor spaces in this way until they are old enough to be tenured (copied to the tenured generation).



## Performance Considerations

- Throughput
- Pauses

In general, choosing the size for a particular generation is a trade-off between these considerations. For example, a very large young generation may maximize throughput, but does so at the expense of footprint, promptness, and pause times. Young generation pauses can be minimized by using a small young generation at the expense of throughput. The sizing of one generation does not affect the collection frequency and pause times for another generation.



## Measurement

### Команда `-verbose:`

Использование команды `-verbose:`



## Sizing the Generations

- The Young Generation
- The Survivor Space Sizing
- The tenured generation
- Virtual space



## Available Collectors

- The serial collector
  - Выбирается на определенном оборудовании, явно может быть назначен `-XX:+UseSerialGC`
- The parallel collector (also known as the throughput collector)
  - Выбирается по дефолту на многопроцессорных машинах со средним или большим размером `Heap`, может быть назначен `-XX:+UseParallelGC`
  - Parallel compaction 
  - Two concurrent collectors. Use the option `-XX:+UseConcMarkSweepGC` to enable the CMS collector or `-XX:+UseG1GC` to enable the G1 collector.



## Selecting a Collector

Important



##  The Parallel Collector



## The Mostly Concurrent Collectors



## Concurrent Mark Sweep (CMS) Collector



## Garbage-First Garbage Collector



## Garbage-First Garbage Collector Tuning





# Вопросы

- Когда выбор `GC` имеет значение?
  - For some applications, the answer is never. That is, the application can perform well in the presence of garbage collection with pauses of modest frequency and duration. However, this is not the case for a large class of applications, particularly those with large amounts of data (multiple gigabytes), many threads, and high transaction rates.
- Как звучит закон Амдала?
  - Amdahl's law (parallel speedup in a given problem is limited by the sequential portion of the problem) implies that most workloads cannot be perfectly parallelized; some portion is always sequential and does not benefit from parallelism.
- Как влияет сборка мусора на потерю пропускной способности на малых и больших системах? И почему?
- "Если сборка мусора занимает 1% времени на однопроцессорной машине. То это приведет к 20% потери пропускной способности при 32 процессорах". Почему так происходит?
  - Связано с законом Амдала, то в идеальных условиях можно ускороить программу в n раз, где n - это количество процессоров. Но каждая задача имеет не параллезируюмую работы (сборка мусора), это снижает потенциальную пропускную способность.
- Когда стоит и не стоит использовать `Serial collector`?
- Когда `Serial collector` выбирается по умолчанию?
- Какой самый простой способ отчистить мусора?
- Почему он не подходит?
- На какой аксиопер построена сборка мусора с использованием поколений?
- Какой сборщик мусора работает по умолчанию?
- Чем различаются `generations` для разных `GC`?
- Сколько раз объекты копируются из `Survivor`?
- Как `GC` решает, что нужно кинуть `OutOfMemoryError`? 
- Можно ли отключить `OutOfMemoryError`?
- Можно ли динамически увеличить память после `OutOfMemoryError`?
- HotSpot VM Frequently Asked Questions (FAQ) -> https://www.oracle.com/technetwork/java/hotspotfaq-138619.html



# Источники

1. [Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/)
2. [Java HotSpot Garbage Collection](https://www.oracle.com/technetwork/java/javase/tech/index-jsp-140228.html)
3. [Open JDK - Storage Management](http://openjdk.java.net/groups/hotspot/docs/StorageManagement.html)
4. Richard Jones and Rafael Lins, *Garbage Collection: Algorithms for Automated Dynamic Memory Management*, Wiley and Sons (1996), ISBN 0-471-94148-4

