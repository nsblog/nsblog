---
layout: post
title: "Структура JVM"
date: 2019-11-30 21:00:00 +0300
categories: jvm
permalink: the-structure-of-the-jvm
---

# Структура `JVM`

## Типы данных

Виртуальная машина Java (`Java Virtual Machine - JVM`) оперирует двумя видами типов: 

- примитивные,
- ссылочные.



### Примитивные типы

Примитивных типов существует всего лишь 8.

| **Типы данных** | Размер        | **Дефолтное значение** |
| --------------- | ------------- | ---------------------- |
| byte            | 8bits = 1byte | 0                      |
| boolean         | 8bits = 1byte | false                  |
| short           | 16bits=2bytes | 0                      |
| char            | 16bits=2bytes | '\u0000'               |
| int             | 32bits=4bytes | 0                      |
| long            | 32bits=4bytes | 0L                     |
| float           | 64bits=8bytes | 0.0f                   |
| double          | 64bits=8bytes | 0.0d                   |



### Ссылочные типы

Cуществует 3 вида ссылочных типов:

1. классы,

2. интерфейсы.

3. массивы.

При создании любого ссылочного типа создается объект и ссылка на этот объект. *Можно провести аналогию, что объект - это телевизор, а ссылка - это пульт.*

- Размер ссылок может быть 4 или 8 байт. 
- Размер объектов - ограничен только размером памяти.



## Области памяти JVM

### Регистр (`pc - Program Counter`)

Регистр (`pc - program counter`) - это приватная область памяти в `RAM`, 

- **выделяется** при создании потока `JVM`, 
- **доступна** только потоку-создателю, 
- **хранит** указатель на текущий исполняемый метод:
  - eсли выполняется `JVM` метод, то регистр хранит `returnAddress` исполняемого метода;
  - eсли выполняется `native` метод, то значение регистра `undefined`.



### Стек (`Stack`)

Стек (`Stack`) - это приватная область памяти в `RAM`, 

- **выделяется** при создании потока `JVM`, 
- **доступна** только потоку-создателю, 
- **хранит** фреймы (`Frame`), которые содержат:
  - локальные переменные,
  - промежуточные результаты,
  - возвращаемые значения,
  - а также отвечают за динамическое связывание и обработку исключений.

Если при вычистлениях требуется больше памяти, то бросится `StackOverflowError`.

> Интересно #1: Cпецификация `JVM` позволяет реализовывать `JVM` c динамически расширяемым `Stack`'ом и кидать `OutOfMemoryError`, в случае превышения памяти.

>Интересно #2: Cпецификация `JVM` позволяет хранить `Frame`'ы в `Heap`, так как `Stack` не изменяется из вне напрямую, кроме создания и удаление `Frame`'ов.



#### `Stack` в `JVM HotSpot`

Размер стека для `JVM HotSpot` может быть задан спомощью `-Xss`:

````java
java -Xss4m Test
````



### Куча (`Heap `)

Куча (`Heap `) - это общая область памяти в `RAM`, 

- **выделяется** при старте `JVM`, 
- **доступна** всем потокам `JVM`. 
- **хранит** экземпляры ссылочных типов:
  - классов, 
  - интерфейсов, 
  - массивов.

Объекты в куче никогда не удаляются явно. Все объекты под контролем `automatic storage management system`, известной как `garbage collector`. Спецификация `JVM` не предполагает конкретного типа `automatic storage management system` и ее реализация зависит только от требования разработчика/заказчика. Куча может быть фиксированного размера или динамически изменяющаяся (расширяющаяся/сжимающаяся) в зависимости от вычислений.

Если при вычистлениях требуется больше памяти, то бросится `OutOfMemoryError`.



#### `Heap` в `JVM HotSpot`

Размер `Heap`'а для `JVM HotSpot` может быть задат с помощью:

- `-Xms256m` - минимальный размер при создании `Heap`'а,
- `-Xmx2048m`- максимальный размер при расширении `Heap`'а.

````bash
java -Xms256m -Xmx6g Test
````



### Область методов (`Method Area`)

Область методов (`Method Area`) - это общая область памяти в `RAM`, 

- **выделяется** при старте `JVM`,
- **доступна** всем потокам `JVM`,
- **хранит** скомпилированный код, а именно структуру для каждого класса:
  - пул констант времени выполнения (`Run-time Constant Pool`),
  - данные о полях и методах класса,
  - код методов и конструкторов,
  - специальные методы `JVM`, в том числе для инициализации классов и интерфейсов.

Хотя `Method Area` является логически частью `Heap`'a, простые реализации могут не собирать мусор с помощью `garbage collector`. `Method Area` может быть фиксированного размера или динамически изменяющаяся (расширяющаяся/сжимающаяся) в зависимости от вычислений.

Если при работе требуется больше памяти, то бросится `OutOfMemoryError`.



#### `Metaspace` - `Method Area` в `JVM HotSpot`

В `JVM HotSpot` с версии `se8` область `Method Area` называется `Metaspace`, ранее область называлась `Permanent Generation`. Для установки минимального и максимального размера области `Metaspace` используются флаги:

- `-XX:MetaspaceSize=256m` - установить началый размер области,
- `-XX:MaxMetaspaceSize=512m` - установить максимальный размер области.

````bash
java -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m  Test
````



### Стек для нативных методов (`Native Method Stacks`)

> Нативный метод (`Native method`) - метод, который написан не на `java`, а например, на `C`. 

Стек для нативных методов (`Native Method Stacks`) - это приватная область памяти в `RAM` ,  необходимая для работы `native methods`, так как обычный стек для этого не подходит,

- **выделяется** при создании потока `JVM`,
- **доступна** только потоку-создателю, 
- **хранит** данные аналогичные обычному `Stack`.

`Native Method Stacks` может быть фиксированного размера или динамически изменяющийся (может расширяться/сужаться) в зависимости от вычислений. 

Если при вычислениях в потоке требуется больше памяти, то бросится `StackOverflowError`. Если нехватка памяти случилась при расширении или при создании/инициализации `Native Method Stacks`, то бросится `OutOfMemoryError`.

> Интересно #1: Cпецификация `JVM` позволяет не реализовывать `Native Method Stacks` и не поддерживать загрузку `native method`.



## Сущности в областях памяти JVM

### Пул констант времени выполнения (`Run-Time Constant Pool`)

Пул констант времени выполнения - это таблица для констант (`constant_pool`), которая хранится в `class file` ,

- **выделяется** при создании каждого класса/интерфейса из `Method Area`;
- **хранит** различные виды констант, начиная от числовых литералов и заканчивая ссылками на методы и поля, которые должны быть доступны в `Run-Time` для реализации позднего связывания.

Если при создании требуется больше памяти, то бросится `OutOfMemoryError`.



### Фрейм (`Frame`)

Фрейм (`Frame`) - это сущность в `JVM`, которая

- **выделяется** из `Stack`'а `JVM`,
- **создается** каждый раз при вызове метода,
- **уничтожается** при завершении метода, либо штатном, либо не штатном (выброс исключения), 
- **доступнен** только потоку-создателю, 
- **служит для**
  - обработки данных и промежуточных результатов,
  - обработки возвращаемого значения из метода,
  - выполнения динамического свазывания,
  - обработки исключений;
- **имеет**
  - собственный массив локальных переменных (`Local Variable Array`),
  - собственный `Operand Stack`,
  - ссылку на `Run-Time Constant Pool` текущего класса,
  - при дебаге спецальную дополнительную информацию.

Размер `Local Variable Array` и `Operand Stack` определяются в `Compile-Time`. Структура данных `Frame` зависит только от реализации `JVM` и память для всех структрур (`Local Variable Array` и `Operand Stack` ) может быть выделена одновременно при вызове метода.

Только один фрейм исполняется в любой точке потока - текущий фрейм (`current frame`), а класс в котором определен метод называется текущим классом (`current class`). Фрейм перестает быть текущим, если его метод вызывает другой метод или метод завершается. Когда новый метод вызывается, то создается новый текущий фрейм, затем управление переходи к новому методу. При возврате метода, текущий фрейм передает обратно результаты в метод вызвавший его. Текущий фрейм удаляется и предыдущий фрейм становится текущим.



### Массив локальных переменных (`Local Variable Array`)

Массив локальных переменных (`Local Variable Array`) - это массив переменных в каждом `Frame`'е,

- **выделяется** при созднии `Frame`'а,
- **доступнен** `Frame`'у-создателю,
- **хранит** следущие типы локальных переменных:
  - `boolean`, 
  - `byte`, 
  - `char`,
  -  `short`,
  -  `int`,
  -  `float`,
  -  `reference`,
  -  `returnAddress`,
  - `long` и `double`  (занимают две локальные переменные).

Размер `Local Variable Array` определяется в `Compile-Time`. Хранится `Local Variable Array` вместе с кодом метода в двоичном представлении класса/интерфейса. 

Спецификация `JVM` резервируют для хранения `long` и `double` две последовательные локальные переменные. Однако спецификация не обязывает выравнивать значения по 64-битной схеме, поэтому разработчики могут реализовывать свои способы храенния `long` и `double`.

Все аргументы метода передаются в `Local Variable Array`, в ячейке с индексом `0` хранится ссылка на объект `this`, далее остальные переменные.



### Стек операндов (`Operand Stacks`)

> Операнд -  аргумент, передаваемый методу.

Стек операндов (`Operand Stacks`) - это стек операндов (`LIFO - last-in-first-out`) в каждом фрейме,

- **создается** при создании `Frame`'а,
- **уничтожается** при уничтожении  `Frame`'а,
- **используется для**
  - подготовки параметров, передаваемых в методы,
  - хранения промежуточных результатов,
  - получения результатов метода,
- **хранит**
  - все значения типов `JVM`, включая `long` и `double`.

Максимальная глубина `Operand Stack`'a определяется в `Compile-Time`. В любой момент времени `Operand Stack` имеет расчитываемую глубину, где значение типа `long` или `double` добавляет две единицы к глубине, а значение любого другого типа - одну единицу. `Operand Stack` пуст при создании `Frame`'а.

Хранится `Operand Stack` вместе с кодом метода, свянанного с фреймов, в двоичном представлении класса/интерфейса.

`JVM` предоставляет инструкции:

- для загрузки значений в `Operand Stack`,
  - констант,
  - локальных переменных,
  - полей,
  - результатов вычислений;
- для извлечения операндов из `Operand Stack`,
- для выполнения вычислений с операндами.

Например, инструкция `iadd` складывает два значения `int`. Требуется, чтобы значения `int`, которые нужно добавить, были двумя верхними значениями `Operand Stack`, выдвинутых туда предыдущими инструкциями. Оба значения `int` извлекаются из `Operand Stack`, затем складываются, а их сумма возвращается в `Operand Stack`. 

Значения из `Operand Stack` должны обрабатываться способами, соответствующими их типам. Например, невозможно извлечь два значения типа `int` и затем обработать их как `long` или извлечь два значения типа `float`, а затем сложить их с помощью инструкции `iadd`.



# Вопросы

**Общее**

1. Какие типы данных существуют в `java`?
2. Сколько примитивынй типов существует и что это за типы?
3. Сколько видов ссылочных типов существует и что это за виды?
4. Массив - это объект? Если - да, то зачем и почему?

**Регистры потока**

1. Что такое регистр поток , как он работает, что хранит?
2. Кто имеет доступ к регистрам потока? Можно ли обращаться из разных потоков?

**Stack**

1. Что такое `Stack` , как он работает, что хранит?
2. Кто имеет доступ к `Stack`? Можно ли обращаться из разных потоков?
3. Размер `Stack` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Stack`?
5. Может ли `Stack` бросить `OutOfMemoryError`?

**Heap**

1. Что такое `heap` , как он работает, что хранит?
2. Кто имеет доступ к `heap`? Можно ли обращаться из разных потоков?
3. Размер `heap` динамически изменяемый?
4. Как задать минимальный и максимальный размер `heap`?
5. Как происходит сборка мусора в `Heap`?

**Method Area**

1. Что такое `Method Area` , как она работает, что хранит?
2. Кто имеет доступ к `Method Area`? Можно ли обращаться из разных потоков?
3. Размер `Method Area` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Method Area`?

**Native Method Stacks**

1. Что такое `Native Method Stacks`, как он работает, что хранит?
2. Кто имеет доступ к `Native Method Stacks`? Можно ли обращаться из разных потоков?
3. Размер `Native Method Stacks` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Native Method Stacks`?
5. Может ли `Native Method Stacks` бросить `OutOfMemoryError`?

**Run-Time Constant Pool**

1. Что такое `Run-Time Constant Pool`, как она работает, что хранит?
2. Кто имеет доступ к `Run-Time Constant Pool`? Можно ли обращаться из разных потоков?
3. Размер ``Run-Time Constant Pool` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Run-Time Constant Pool`?

**Frame**

1. Что такое `Frame`, как он работает, что хранит?
2. Какова структура `Frame`?
3. Когда создается и уничтожается `Frame`?
4. Как переходит управление от `Frame`'а к `Frame`'у? При вызове метода и при возврате значения?
5. Кто имеет доступ к `Frame`? Можно ли обращаться из разных потоков?
6. Как выделяется память для `Frame` и для его структуры?
7. Как задать минимальный и максимальный размер `Frame`?

**Local Variable Array**

1. Что такое `Local Variable Array`, как он работает, что хранит?
2. Как хранятся переменные `long` и `double`?
3. Зачем существует возможность хранения `returnAddress`?
4. Когда создается и уничтожается `Local Variable Array`?
5. Как определяется длина `Local Variable Array`?
6. Что хранится в нулевом индексе `Local Variable Array`?

**Operand Stacks**

1. Что такое операнд?
2. Что такое `Operand Stacks`, для чего служит?
3. Что хранит `Operand Stacks`?
4. Как хранятся переменные `long` и `double`?
5. Когда создается и уничтожается `Operand Stacks`?
6. Как и когда определяется максимальная глубина `Operand Stacks`?
7. Что хранит `Operand Stacks` при создании?
8. Как `JVM` работает с `Operand Stacks` на примере сложения двух `int`?
9. `JVM` использует для разных типов, например `int` и `long` одиннаковые или разные инструкции? И почему?

**Extended**

1. `Stack` и `Heap` расположены оба в `RAM`, правильно? Где доступ быстрее и почему в `Stack` или `Heap`?



# Источники

1. [Primitive Data Types](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
2. [The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html)



# TODO

## Вопросы 

1. Как определить диапазон значений по размеру примитивного типа? (планировалось как параграф после типов данных)
2. Что такое `statically-typed`?
   - [The Java programming language is statically-typed, which means that all variables must first be declared before they can be used.](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
3. Для чего можно и нельзя использовать `float` and `double` ?
4. Зачем существует класс `BigDecimal`?
5. [Почему "Relying on such default values, however, is generally considered bad programming style"?](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
6. [Как происходит динамическое связывание?](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.6.3)

## Источники

- Википедия - Регистр процессора](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0)
- https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html
- https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html
- https://www.baeldung.com/java-stack-heap