---

---

# Java memory model - Основа

## Типы данных

Виртуальная машина Java (`Java Virtual Machine - JVM`) оперирует двумя видами типов: 

- примитивные,
- ссылочные.



### Примитивные типы

Примитивных типов существует всего лишь 8.

| **Типы данных** | Размер        | **Дефолтное значение** |
| --------------- | ------------- | ---------------------- |
| byte            | 8bits = 1byte | 0                      |
| boolean         | 8bits = 1byte | false                  |
| short           | 16bits=2bytes | 0                      |
| char            | 16bits=2bytes | '\u0000'               |
| int             | 32bits=4bytes | 0                      |
| long            | 32bits=4bytes | 0L                     |
| float           | 64bits=8bytes | 0.0f                   |
| double          | 64bits=8bytes | 0.0d                   |



### Ссылочные типы

Cуществует 3 вида ссылочных типов:

1. классы,

2. интерфейсы.

3. массивы.

При создании любого ссылочного типа создается объект и ссылка на этот объект. *Можно провести аналогию, что объект - это телевизор, а ссылка - это пульт.*

- Размер ссылок может быть 4 или 8 байт. 
- Размер объектов - ограничен только размером памяти.



### Как определить диапазон значений по размеру примитивного типа?

TODO



## Типы памяти JVM

### Регистр (`pc - program counter`)

Регистр (`pc - program counter`) - это приватная область памяти в `RAM`, 

- **выделяется** при создании потока `JVM`, 
- **доступна** только потоку-создателю, 
- **хранит** указатель на текущий исполняемый метод:
  - eсли выполняется `JVM` метод, то регистр хранит `returnAddress` исполняемого метода;
  - eсли выполняется `native` метод, то значение регистра `undefined`.



### Стек (`Stack`)

Стек (`Stack`) - это приватная область памяти в `RAM`, 

- **выделяется** при создании потока `JVM`, 
- **доступна** только потоку-создателю, 
- **хранит** фреймы (`frame`), которые содержат:
  - локальные переменные,
  - промежуточные результаты,
  - возвращаемые значения,
  - а также отвечают за динамическое связывание и обработку исключений.

Если при вычистлениях требуется больше памяти, то бросится `StackOverflowError`.

> Интересно #1: Cпецификация `JVM` позволяет реализовывать `JVM` c динамически расширяемым `stack`'ом и кидать `OutOfMemoryError`, в случае превышения памяти.

>Интересно #2: Cпецификация `JVM` позволяет хранить `frame`'ы в `heap`, так как `stack` не изменяется из вне напрямую, кроме создания и удаление `frame`'ов.

#### JVM HotSpot

Размер стека для `JVM HotSpot` может быть задан спомощью `-Xss`:

````java
java -Xss4m Test
````



### Куча (`Heap `)

Куча (`Heap `) - это общая область памяти в `RAM`, 

- **выделяется** при старте `JVM`, 
- **доступна** всем потокам `JVM`. 
- **хранит** экземпляры ссылочных типов:
  - классов, 
  - интерфейсов, 
  - массивов.

Объекты в куче никогда не удаляются явно. Все объекты под контролем `automatic storage management system`, известной как `garbage collector`. Спецификация `JVM` не предполагает конкретного типа `automatic storage management system` и ее реализация зависит только от требования разработчика/заказчика. Куча может быть фиксированного размера или динамически изменяющаяся (расширяющаяся/сжимающаяся) в зависимости от вычислений.

Если при вычистлениях требуется больше памяти, то бросится `OutOfMemoryError`.

#### JVM HotSpot

Размер `heap`'а для `JVM HotSpot` может быть задат с помощью:

- `-Xms256m` - минимальный размер при создании `heap`'а,
- `-Xmx2048m`- максимальный размер при расширении `heap`'а.

````bash
java -Xms256m -Xmx6g Test
````



## Область методов (`Method Area`)

Область методов (`Method Area`) - это общая область памяти в `RAM`, 

- **выделяется** при старте `JVM`,
- **доступна** всем потокам `JVM`. 
- **хранит** хранит скомпилированный код, хранит структуру для каждого класса, а именно:
  - пул констант времени выполнения (`the run-time constant pool`),
  - данные о полях и методах класса,
  - код методов и конструкторов,
  - специальные методы `JVM`, в том числе для инициализации классов и интерфейсов.

Хотя `Method Area` является логически частью `heap`, простые реализации могут не собирать мусор с помощью `garbage collector`. `Method Area` может быть фиксированного размера или динамически изменяющаяся (расширяющаяся/сжимающаяся) в зависимости от вычислений.

Если при работе требуется больше памяти, то бросится `OutOfMemoryError`.

#### JVM HotSpot

В `JVM HotSpot, java 8` область, которая хранит скомпилированный код называется `Metaspace`:

- `-XX:MetaspaceSize=256m` - установить началый размер области,
- `-XX:MaxMetaspaceSize=512m` - установить максимальный размер области.

````bash
java -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m  Test
````



#### Пул констант времени выполнения (`Run-Time Constant Pool`)

Пул констант времени выполнения - это таблица для констант (`constant_pool`), хранится в `class file` ,

- **выделяется** при создании каждого класса/интерфейса из `Method Area`
- **хранит** различные виды констант, начиная от числовых литералов и заканчивая ссылками на методы и поля, которые должны быть доступны в `run-time`.

Если при создании требуется больше памяти, то бросится `OutOfMemoryError`.







### Native Method Stacks

`Native Method Stacks` - стек, чтобы поддерживать работу с `native method`'ами.

`Native method` - это методы, написанные не на `Java`.

`Native method stacks` также могут использоваться как реализация интерпритатора в `JVM` для кода на `C`.

Реализации `JVM` которые не могу загружать `native` методы и которые сами не полагаются на обычные стеки, не должны поставлять ` native method stacks`.

Если это предуспотрено, `native method stacks` обычно выделяются для каждого потока, при его создании.

Эта спецификация разрешает `native method stacks` либо быть фиксированного размера, либо динамически расширяться и сужаться в зависимости от вычислений.

Если `native method stacks` фиксированного размера, тогда размер каждого `native method stack` может быть выбран независимо при создании стека.

Реализация `JVM` может предоставлять программисту или пользователю контроль над начальным размером `native method stacks`, так же как в случае переменного размера `native method stack` контролировать максимальный и минимальный размер.

Следующие ошибки могут произойти с `native method stacks`:

Если вычисления в потоке требуют больший `native method stack`, чем разрешен, тогда кидать `StackOverflowError`.

Если `native method stacks` может динамически расширяться, но при попытке расширения не хватает памяти или нехватка памяти случается при создани или инициализации `native method stack ` для нового потока, то `JVM` кидает `OutOfMemoryError`.



## Фреймы (Frames)

Фреймы используются для хранения данных и промежуточных результатов, а также для выполнения динамического связывания, возврата значений из методов и обработки исключений.

Новый фрейм создается каждый раз при вызове метода. Фрейм уничтожается, когда метод завершается либо нормально, либо пререывается, если бросается несловленное исключение. Фреймы выделяются из стека `JVM` потока создавшего кадр. Каждый фрейм имеет собственный массив или локальные переменные, собственный `operand stack` и ссылку на `run-time constant pool ` класса текущего метода.

Фрейм может быть расширен дополнительной специально информацией, такой как информация для дебага.

Размер `local variable array` и `operand stack` определяются в `compile-time ` и поставляются вместе с кодом для метода, связанного с фреймом.

Таким образом размер структуры данных кадра зависит только от реализации `JVM` и память для этих структур может быть выделена одновременно при вызове метода.

Только один фрейм, фрейм исполняемого метода, активен в любой точке данной потока.

Это фрейм - называется текущим фреймом `current frame` и его метод называется текущим методом `current method`.

Класс в котором текущий метод определен назвается текущим классом `current class`. Операции над локальными переменными и ` operand stack` обычно выполняются со ссылкой на текущий фрейм.

Фрейм перестает быть текущим, если его метод вызывает другой метод или его метод завершается.

Когда метод вызывается, новый фрейм создается и становится текущим, затем управление переходи к новому методу.

При возврате метода, текущий фрейм передат обратно результат в метод вызвавший его, если таковой имеется, в предыдущий кадр.

Текущий фрейм затем удаляется и предудущий фрейм становится текущим.

Обратите внимание, что фрей созданный потоком является локальным для этого потока и на него не может ссылаться ни один другой поток.



### Локальные переменные (`Local Variables`)

Каждый фрейм содержит ` array of variables` также известный как массив переменных. Длина `local variable array` фрейма определяется в `compile-time` и представляется в двоичном представлении класса/интерфейса вместе с кодом метода, связанного с фреймом.

Одна локальная переменная может содержать значения типа  `boolean`, `byte`, `char`, `short`, `int`, `float`, `reference` или `returnAddress`. Пара локальных переменных может содержать значения `long` и `double`.

Локальные переменные адресуются с помощью индексации. Индекс первой локальной переменной - 0. `Integer` (целое число?) считается индексом в ` local variable array`, если и только если это целое число между нулем и на единицу меньше размера массива.

Значение типа `long` и `double` занимают две последовательные локальные переменные. Такое значение может быть адрессовано только с использованием меньшего индекса.

Например, значение `double` хранящееся в ` local variable array` по индексу `n` фактически занимает локальную переменную с индексами `n` и `n+1`; однако, локальная переменаая с индексом `n+1` не может быть загружена. It can be stored into. (?) Однако это делает недействительным содержимое локальной переменной с индексом `n`.

`JVM` не требует чтобы `n` был четным. В интуитивно понятных терминах значение `long` и `double` не должно быть воровнено по 64-битной схеме в `local variables array`.

Разработчики могут сами выбрать подходящий способ представления таких значений, используя две локальные переменные, зарезервированные для значения.

`JVM` использует локальные переменные для передачи параметров при вызове метода.

При вызове метода класса любые параметры передаются в последовательных локальных переменных, начиная с локальной переменной 0.

При вызове экземпляра метода локальная переменная 0 всегда используется для передачи ссылки на объект, для которого вызывается метод экземпляра (`this` в языке программирования Java).

Любые параметры впоследствии передаются в последовательных локальных переменных, начиная с локальной переменной 1.



### Operand Stacks

Каждый фрейм содержит стек `last-in-first-out` (LIFO), известный как `operand stack`.

Максимальная глубина стека операндов кадра определяется во время компиляции и предоставляется вместе с кодом для метода, связанного с фреймом.

Там, где это ясно по контексту, мы иногда будем называть `operand stack` текущего фрейма просто стеком операндов.

Стек операнда пуст при создании кадра, который его содержит.

`JVM` предоставляет инструкции для загрузки констант или значений из локальных переменных или полей в стек операндов.

Другие инструкции виртуальной машины Java берут операнды из стека операндов, оперируют с ними и помещают результат обратно в стек операндов.

Стек операндов также используется для подготовки параметров, передаваемых в методы, и для получения результатов метода.

Например, инструкция iadd (§iadd) добавляет два значения int вместе.

Требуется, чтобы значения int, которые нужно добавить, были двумя верхними значениями стека операндов, выдвинутых туда предыдущими инструкциями.

Оба значения int извлекаются из стека операндов. Они добавляются, а их сумма возвращается в стек операндов. Подкомпьютеры могут быть вложены в стек операндов, что приводит к значениям, которые могут использоваться охватывающим вычислением.

Каждая запись в стеке операндов может содержать значение любого типа виртуальной машины Java, включая значение типа long или типа double.

Значения из стека операндов должны обрабатываться способами, соответствующими их типам. Например, невозможно выдвинуть два значения типа int и затем обработать их как long или выдвинуть два значения типа float, а затем добавить их с помощью инструкции iadd. Небольшое количество инструкций виртуальной машины Java (инструкции dup (§dup) и swap (§swap)) работают с областями данных времени выполнения в виде необработанных значений без учета их конкретных типов; Эти инструкции определены таким образом, что их нельзя использовать для изменения или разбивки отдельных значений. Эти ограничения на работу со стеком операндов применяются посредством проверки файла класса (§4.10).

В любой момент времени стек операндов имеет связанную глубину, где значение типа long или double добавляет две единицы к глубине, а значение любого другого типа - одну единицу.



### Dynamic Linking

Каждый кадр содержит ссылку на пул констант во время выполнения для типа текущего метода для поддержки динамическое связывание кода метода. Код файла `class` для метода относится к вызываемым методам и переменным, доступ к которым осуществляется через символические ссылки. **символические ссылки?**

Динамическое связывание преобразует эти символьные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимости для разрешения пока еще не определенных символов, и преобразует обращения к переменным в соответствующие смещения в структурах хранения, связанных с расположением этих переменных во время выполнения.

Позднее связывание методов и переменных вносит изменения в другие классы, которые метод использует с меньшей вероятностью нарушить этот код.



### Normal Method Invocation Completion

Вызов метода завершается нормально, если этот вызов не вызывает исключение для выброса, либо непосредственно из виртуальной машины Java, либо в результате выполнения явного оператора `throw`. Если вызов текущего метода завершается нормально, то значение может быть возвращено вызывающему методу. Это происходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которого должен соответствовать типу возвращаемого значения (если оно есть).

Текущий кадр в этом случае используется для восстановления состояния invoker, включая его локальные переменные и стек операндов, с программным счетчиком invoker, соответствующим образом увеличенным, чтобы пропустить инструкцию вызова метода. Затем выполнение обычно продолжается в кадре вызывающего метода с возвращенным значением (если оно есть), помещаемым в стек операндов этого кадра.



### Abrupt Method Invocation Completion

Вызов метода завершается преждевременно, если при выполнении инструкции виртуальной машины Java в методе виртуальная машина Java выдает исключение (§2.10), и это исключение не обрабатывается в методе. Выполнение команды athrow (§athrow) также вызывает явное генерирование исключения и, если текущий метод не обнаруживает исключение, приводит к неожиданному завершению вызова метода. Вызов метода, который завершается внезапно, никогда не возвращает значение своему вызывающему.







## Пример программы!



The Java Virtual Machine expects that nearly all type checking is done prior to run time, typically by a compiler, and does not have to be done by the Java Virtual Machine itself.

The Java Virtual Machine contains explicit support for objects. An object is either a dynamically allocated class instance or an array

A reference to an object is considered to have Java Virtual Machine type `reference`



**Картинка**

![]({{ site.baseurl }}/img/functional-interfaces/1.png)



# Вопросы

**Общее**

1. Какие типы данных существуют в `java`?
2. Сколько примитивынй типов существует и что это за типы?
3. Сколько видов ссылочных типов существует и что это за виды?
4. Массив - это объект? Если - да, то зачем и почему?

**Регистры потока**

1. Что такое регистр поток и как он работает, что хранит?
2. Кто имеет доступ к регистрам потока? Можно ли обращаться из разных потоков?

**Stack**

1. Что такое `stack` и как он работает, что хранит?
2. Кто имеет доступ к `stack`? Можно ли обращаться из разных потоков?
3. Размер `stack` динамически изменяемый?
4. Как задать минимальный и максимальный размер `stack`?

**Heap**

1. Что такое `heap` и как он работает, что хранит?
2. Кто имеет доступ к `heap`? Можно ли обращаться из разных потоков?
3. Размер `heap` динамически изменяемый?
4. Как задать минимальный и максимальный размер `heap`?
5. Как происходит сборка мусора в `Heap`?

**Method Area**

1. Что такое `Method Area` и как она работает, что хранит?
2. Кто имеет доступ к `Method Area`? Можно ли обращаться из разных потоков?
3. Размер `Method Area` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Method Area`?

**Run-Time Constant Pool**

1. Что такое `Run-Time Constant Pool` и как она работает, что хранит?
2. Кто имеет доступ к `Run-Time Constant Pool`? Можно ли обращаться из разных потоков?
3. Размер ``Run-Time Constant Pool` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Run-Time Constant Pool`?

**Extended**

1. `Stack` и `Heap` расположены оба в `RAM`, правильно? Где доступ быстрее и почему в `Stack` или `Heap`?









Другие вопросы

1. Что такое `statically-typed`?
   - [The Java programming language is statically-typed, which means that all variables must first be declared before they can be used.](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
2. Для чего можно и нельзя использовать `float` and `double` ?
3. Зачем существует класс `BigDecimal`?
4. [Почему "Relying on such default values, however, is generally considered bad programming style"?](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)



# Источники

1. [Primitive Data Types](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
2. [The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html) 
3. [Стек и куча в Java](https://topjava.ru/blog/stack-and-heap-in-java)  



4. [Википедия - Регистр процессора](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0)
5. https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html
6. https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html
7. https://www.baeldung.com/java-stack-heap



## [Скачать приложение]({{ site.baseurl }}/download/01-java/functional-interfaces.zip)