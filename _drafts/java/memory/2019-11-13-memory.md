---
layout: post
title: "Структура JVM"
date: 2019-11-30 21:00:00 +0300
categories: jvm
permalink: the-structure-of-the-jvm
---

# Структура `JVM`

Описанны типы данных `JVM`, типы памяти и основные сущности в памяти `JVM`.

## Типы данных

Виртуальная машина Java (`Java Virtual Machine - JVM`) оперирует двумя видами типов: 

- примитивные,
- ссылочные.



### Примитивные типы

Примитивных типов существует всего лишь 8.

| **Типы данных** | Размер          | **Дефолтное значение** |
| --------------- | --------------- | ---------------------- |
| byte            | 8bits = 1byte   | 0                      |
| boolean         | 8bits = 1byte   | false                  |
| short           | 16bits = 2bytes | 0                      |
| char            | 16bits = 2bytes | '\u0000'               |
| int             | 32bits = 4bytes | 0                      |
| long            | 32bits = 4bytes | 0L                     |
| float           | 64bits = 8bytes | 0.0f                   |
| double          | 64bits = 8bytes | 0.0d                   |



### Ссылочные типы

Cуществует 3 вида ссылочных типов:

1. классы,

2. интерфейсы.

3. массивы.

При создании любого ссылочного типа создается объект и ссылка на этот объект. *Можно провести аналогию, что объект - это телевизор, а ссылка - это пульт.*

- Размер ссылок может быть 4 или 8 байт. 
- Размер объектов - ограничен только размером памяти.



## Области памяти JVM

### Регистр (`pc - Program Counter`)

Регистр (`pc - program counter`) - это приватная область памяти, 

- **выделяется** при создании потока `JVM`, 
- **доступна** только потоку-создателю, 
- **хранит** указатель на текущий исполняемый метод:
  - eсли выполняется `java`-метод, то регистр хранит `returnAddress` исполняемого метода;
  - eсли выполняется `native`-метод, то значение регистра `undefined`.



### Стек (`Stack`)

Стек (`Stack`) - это приватная область памяти, 

- **выделяется** при создании потока `JVM`, 
- **доступна** только потоку-создателю, 
- **хранит** фреймы (`Frame`), которые содержат:
  - локальные переменные,
  - промежуточные результаты,
  - возвращаемые значения,
  - а также отвечают за динамическое связывание и обработку исключений.

Если при вычистлениях требуется больше памяти, то бросится `StackOverflowError`.

> Интересно #1: Cпецификация `JVM` позволяет реализовывать `JVM` c динамически расширяемым `Stack`'ом и кидать `OutOfMemoryError`, в случае превышения памяти.

>Интересно #2: Так как `Stack` приватная область памяти, cпецификация `JVM` позволяет хранить `Frame`'ы в `Heap`.



#### `Stack` в `JVM HotSpot`

Размер стека для `JVM HotSpot` может быть задан спомощью `-Xss`:

````bash
java -Xss4m Test
````



### Куча (`Heap `)

Куча (`Heap `) - это общая область памяти, 

- **выделяется** при старте `JVM`, 
- **доступна** всем потокам `JVM`. 
- **хранит** <u>экземпляры</u> ссылочных типов:
  - классов, 
  - интерфейсов, 
  - массивов.

Объекты в куче никогда не удаляются явно. Все объекты под контролем `automatic storage management system`, известной как `garbage collector`. Спецификация `JVM` не предполагает конкретного типа `automatic storage management system` и ее реализация зависит только от требования разработчика/заказчика. Куча может быть фиксированного размера или динамически изменяющаяся (может расширяться/сужаться) в зависимости от вычислений.

Если при вычистлениях требуется больше памяти, то бросится `OutOfMemoryError`.



#### `Heap` в `JVM HotSpot`

Размер `Heap`'а для `JVM HotSpot` может быть задат с помощью:

- `-Xms256m` - установить началый размер `Heap`'а,
- `-Xmx2048m`- установить максимальный размер `Heap`'а.

````bash
java -Xms256m -Xmx6g Test
````



### Область методов (`Method Area`)

Область методов (`Method Area`) - это общая область памяти, 

- **выделяется** при старте `JVM`,
- **доступна** всем потокам `JVM`,
- **хранит** скомпилированный код, а именно структуру для каждого класса:
  - пул констант времени выполнения (`Run-time Constant Pool`),
  - данные о полях и методах класса,
  - код методов и конструкторов,
  - специальные методы `JVM`, в том числе для инициализации классов и интерфейсов.

Хотя `Method Area` является логически частью `Heap`'a, простые реализации могут не собирать мусор с помощью `garbage collector`. `Method Area` может быть фиксированного размера или динамически изменяющаяся (может расширяться/сужаться) в зависимости от вычислений.

Если при работе требуется больше памяти, то бросится `OutOfMemoryError`.



#### `Metaspace` - `Method Area` в `JVM HotSpot`

В `JVM HotSpot` с версии `se8` область `Method Area` называется `Metaspace`, ранее область называлась `Permanent Generation`. Для установки минимального и максимального размера области `Metaspace` используются флаги:

- `-XX:MetaspaceSize=256m` - установить началый размер `Metaspace`,
- `-XX:MaxMetaspaceSize=512m` - установить максимальный размер `Metaspace`.

````bash
java -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m Test
````



### Стек для нативных методов (`Native Method Stack`)

> Нативный метод (`native method`) - метод написанный не на `java`, а например, на `C`, `C++` и тд. 

Стек для нативных методов (`Native Method Stack`) - это приватная область памяти, необходимая для работы `native method`'ов, так как обычный стек для этого не подходит. Память

- **выделяется** при создании потока `JVM`,
- **доступен** только потоку-создателю, 
- **хранит** данные аналогичные обычному `Stack`.

`Native Method Stack` может быть фиксированного размера или динамически изменяющийся (может расширяться/сужаться) в зависимости от вычислений. 

Если при вычислениях в потоке требуется больше памяти, то бросится `StackOverflowError`. Если нехватка памяти случилась при расширении или при создании/инициализации `Native Method Stack`, то бросится `OutOfMemoryError`.

> Интересно #1: Cпецификация `JVM` позволяет не реализовывать `Native Method Stack` и не поддерживать загрузку `native method`'ов.



## Сущности в областях памяти JVM

### Пул констант времени выполнения (`Run-Time Constant Pool`)

Пул констант времени выполнения - это таблица для констант (`constant_pool`), которая хранится в бинарном представлении класса/интерфейса в `class file`. Память для пула

- **выделяется** при создании <u>каждого</u> класса/интерфейса из `Method Area`;
- **хранит** различные виды констант, начиная от числовых литералов и заканчивая ссылками на методы и поля, которые должны быть доступны в `Run-Time` для реализации динамического связывания.

Если при создании требуется больше памяти, то бросится `OutOfMemoryError`.



### Фрейм (`Frame`)

Фрейм (`Frame`) - это сущность в `JVM`, память 

- **выделяется** из `Stack`'а `JVM`,
- `Frame` **создается** каждый раз при вызове метода,
- **уничтожается** при завершении метода, либо штатном, либо не штатном (выброс исключения), 
- **доступнен** только потоку-создателю, 
- **служит для**
  - обработки данных и промежуточных результатов,
  - обработки возвращаемого значения из метода,
  - выполнения динамического свазывания,
  - обработки исключений;
- **имеет**
  - собственный массив локальных переменных (`Local Variable Array`),
  - собственный `Operand Stack`,
  - ссылку на `Run-Time Constant Pool` текущего класса,
  - при дебаге спецальную дополнительную информацию.

Размер `Local Variable Array` и `Operand Stack` определяются в `Compile-Time`. Структура данных `Frame` зависит только от реализации `JVM` и память для всех структрур (`Local Variable Array` и `Operand Stack` ) может быть выделена одновременно при вызове метода (создании `Frame`'а).

Только один фрейм исполняется в любой точке потока - текущий фрейм (`current frame`), а класс в котором определен метод называется текущим классом (`current class`). Фрейм перестает быть текущим, если его метод вызывает другой метод или метод завершается. Когда новый метод вызывается, то создается новый текущий фрейм, затем управление переходи к новому методу. При возврате метода, текущий фрейм передает обратно результаты в метод вызвавший его. Текущий фрейм удаляется и предыдущий фрейм становится текущим.



### Массив локальных переменных (`Local Variable Array`)

Массив локальных переменных (`Local Variable Array`) - это массив переменных в каждом `Frame`'е,

- **выделяется** при созднии `Frame`'а,
- **доступнен** `Frame`'у-создателю,
- **хранит** следущие типы локальных переменных:
  - `boolean`, 
  - `byte`, 
  - `char`,
  -  `short`,
  -  `int`,
  -  `float`,
  -  `reference`,
  -  `returnAddress`,
  - `long` и `double`  (занимают две локальные переменные).

Размер `Local Variable Array` определяется в `Compile-Time`. Хранится `Local Variable Array` вместе с кодом метода в бинарном представлении класса/интерфейса в `class file`.

Спецификация `JVM` резервирует для хранения `long` и `double` две последовательные локальные переменные. Однако спецификация не обязывает выравнивать значения по 64-битной схеме, поэтому разработчики свободны реализовывать собственные варианты хранения `long` и `double`.

Все аргументы метода передаются в `Local Variable Array`, в ячейке с индексом `0` хранится ссылка на объект `this`, далее остальные переменные.



### Стек операндов (`Operand Stack`)

> Операнд -  аргумент, передаваемый методу.

Стек операндов (`Operand Stack`) - это стек операндов (`LIFO - last-in-first-out`) в каждом `Frame`'е,

- **создается** при создании `Frame`'а,
- **уничтожается** при уничтожении  `Frame`'а,
- **используется для**
  - подготовки параметров, передаваемых в методы,
  - хранения промежуточных результатов,
  - получения результатов метода,
- **хранит**
  - все значения типов `JVM`, включая `long` и `double`.

Максимальная глубина `Operand Stack`'a определяется в `Compile-Time`. В любой момент времени `Operand Stack` имеет определяемую глубину, где значение типа `long` или `double` добавляет две единицы к глубине, а значение любого другого типа - одну единицу. `Operand Stack` пуст при создании `Frame`'а.

Хранится `Operand Stack` вместе с кодом метода, свянанного с фреймов, в бинарном представлении класса/интерфейса в `class file`. 

`JVM` предоставляет инструкции:

- для загрузки значений в `Operand Stack`,
  - констант,
  - локальных переменных,
  - полей,
  - результатов вычислений;
- для извлечения операндов из `Operand Stack`,
- для выполнения вычислений с операндами.

Например, инструкция `iadd` складывает два значения `int`. Требуется, чтобы значения `int`, которые нужно добавить, были двумя верхними значениями `Operand Stack`, выдвинутыми туда предыдущими инструкциями. Оба значения `int` извлекаются из `Operand Stack`, затем складываются, а их сумма возвращается в `Operand Stack`. 

Значения из `Operand Stack` должны обрабатываться способами, соответствующими их типам. Например, невозможно извлечь два значения типа `int` и затем обработать их как `long` или извлечь два значения типа `float`, а затем сложить их с помощью инструкции `iadd`.



# Вопросы

**Общее**

1. Какие типы данных существуют в `java`?
2. Перечислите примитивные типы в `Java`? Сколько их?
3. Сколько видов ссылочных типов существует и что это за виды?
4. Массив - это объект? Если - да, то зачем и почему?

**Регистры потока**

1. Что такое регистр потока, как он работает, что хранит?
2. Кто имеет доступ к регистрам потока? Можно ли обращаться из разных потоков?

**Stack**

1. Что такое `Stack` , как он работает, что хранит?
2. Кто имеет доступ к `Stack`? Можно ли обращаться из разных потоков?
3. Размер `Stack` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Stack`?
5. Может ли `Stack` бросить `OutOfMemoryError`?

**Heap**

1. Что такое `Heap` , как он работает, что хранит?
2. Кто имеет доступ к `Heap`? Можно ли обращаться из разных потоков?
3. Размер `Heap` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Heap`?
5. Как происходит сборка мусора в `Heap`?

**Method Area**

1. Что такое `Method Area`, как она работает, что хранит?
2. Кто имеет доступ к `Method Area`? Можно ли обращаться из разных потоков?
3. Размер `Method Area` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Method Area`?

**Native Method Stack**

1. Что такое `Native Method Stack`, как он работает, что хранит?
2. Кто имеет доступ к `Native Method Stack`? Можно ли обращаться из разных потоков?
3. Размер `Native Method Stack` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Native Method Stack`?
5. Может ли `Native Method Stack` бросить `OutOfMemoryError`?

**Run-Time Constant Pool**

1. Что такое `Run-Time Constant Pool`, как она работает, что хранит?
2. Кто имеет доступ к `Run-Time Constant Pool`? Можно ли обращаться из разных потоков?
3. Размер `Run-Time Constant Pool` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Run-Time Constant Pool`?

**Frame**

1. Что такое `Frame`, как он работает, что хранит?
2. Какова структура `Frame`?
3. Когда создается и уничтожается `Frame`?
4. Как переходит управление от `Frame`'а к `Frame`'у? При вызове метода и при возврате значения?
5. Кто имеет доступ к `Frame`? Можно ли обращаться из разных потоков?
6. Как выделяется память для `Frame` и для его структуры?
7. Как задать минимальный и максимальный размер `Frame`?

**Local Variable Array**

1. Что такое `Local Variable Array`, как он работает, что хранит?
2. Как хранятся переменные `long` и `double`?
3. Зачем существует возможность хранения `returnAddress`?
4. Когда создается и уничтожается `Local Variable Array`?
5. Как определяется длина `Local Variable Array`?
6. Что хранится в нулевом индексе `Local Variable Array`?

**Operand Stack**

1. Что такое операнд?
2. Что такое `Operand Stack`, для чего служит?
3. Что хранит `Operand Stack`?
4. Как хранятся переменные `long` и `double`?
5. Когда создается и уничтожается `Operand Stack`?
6. Как и когда определяется максимальная глубина `Operand Stack`?
7. Что хранит `Operand Stack`при создании?
8. Как `JVM` работает с `Operand Stack` на примере сложения двух `int`?
9. `JVM` использует для разных типов, например `int` и `long` одиннаковые или разные инструкции? И почему?

**Extended**

1. `Stack` и `Heap` расположены оба в `RAM`, правильно? Где доступ быстрее в `Stack` или `Heap` и почему?



# Источники

1. [Primitive Data Types](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
2. [The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html)