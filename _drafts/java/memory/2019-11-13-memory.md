---

---

# Java memory model - Основа

## Типы данных

Виртуальная машина Java (`Java Virtual Machine - JVM`) оперирует двумя видами типов: 

- примитивные,
- ссылочные.



### Примитивные типы

Примитивных типов существует всего лишь 8.

| **Типы данных** | Размер        | **Дефолтное значение** |
| --------------- | ------------- | ---------------------- |
| byte            | 8bits = 1byte | 0                      |
| boolean         | 8bits = 1byte | false                  |
| short           | 16bits=2bytes | 0                      |
| char            | 16bits=2bytes | '\u0000'               |
| int             | 32bits=4bytes | 0                      |
| long            | 32bits=4bytes | 0L                     |
| float           | 64bits=8bytes | 0.0f                   |
| double          | 64bits=8bytes | 0.0d                   |



### Ссылочные типы

Cуществует 3 вида ссылочных типов:

1. классы,

2. интерфейсы.

3. массивы.

При создании любого ссылочного типа создается объект и ссылка на этот объект. *Можно провести аналогию, что объект - это телевизор, а ссылка - это пульт.*

- Размер ссылок может быть 4 или 8 байт. 
- Размер объектов - ограничен только размером памяти.



### Как определить диапазон значений по размеру примитивного типа?

TODO



## Типы памяти JVM

### Регистр (`pc - Program Counter`)

Регистр (`pc - program counter`) - это приватная область памяти в `RAM`, 

- **выделяется** при создании потока `JVM`, 
- **доступна** только потоку-создателю, 
- **хранит** указатель на текущий исполняемый метод:
  - eсли выполняется `JVM` метод, то регистр хранит `returnAddress` исполняемого метода;
  - eсли выполняется `native` метод, то значение регистра `undefined`.



### Стек (`Stack`)

Стек (`Stack`) - это приватная область памяти в `RAM`, 

- **выделяется** при создании потока `JVM`, 
- **доступна** только потоку-создателю, 
- **хранит** фреймы (`Frame`), которые содержат:
  - локальные переменные,
  - промежуточные результаты,
  - возвращаемые значения,
  - а также отвечают за динамическое связывание и обработку исключений.

Если при вычистлениях требуется больше памяти, то бросится `StackOverflowError`.

> Интересно #1: Cпецификация `JVM` позволяет реализовывать `JVM` c динамически расширяемым `Stack`'ом и кидать `OutOfMemoryError`, в случае превышения памяти.

>Интересно #2: Cпецификация `JVM` позволяет хранить `Frame`'ы в `Heap`, так как `Stack` не изменяется из вне напрямую, кроме создания и удаление `Frame`'ов.



#### `Stack` в `JVM HotSpot`

Размер стека для `JVM HotSpot` может быть задан спомощью `-Xss`:

````java
java -Xss4m Test
````



### Куча (`Heap `)

Куча (`Heap `) - это общая область памяти в `RAM`, 

- **выделяется** при старте `JVM`, 
- **доступна** всем потокам `JVM`. 
- **хранит** экземпляры ссылочных типов:
  - классов, 
  - интерфейсов, 
  - массивов.

Объекты в куче никогда не удаляются явно. Все объекты под контролем `automatic storage management system`, известной как `garbage collector`. Спецификация `JVM` не предполагает конкретного типа `automatic storage management system` и ее реализация зависит только от требования разработчика/заказчика. Куча может быть фиксированного размера или динамически изменяющаяся (расширяющаяся/сжимающаяся) в зависимости от вычислений.

Если при вычистлениях требуется больше памяти, то бросится `OutOfMemoryError`.



#### `Heap` в `JVM HotSpot`

Размер `Heap`'а для `JVM HotSpot` может быть задат с помощью:

- `-Xms256m` - минимальный размер при создании `Heap`'а,
- `-Xmx2048m`- максимальный размер при расширении `Heap`'а.

````bash
java -Xms256m -Xmx6g Test
````



### Область методов (`Method Area`)

Область методов (`Method Area`) - это общая область памяти в `RAM`, 

- **выделяется** при старте `JVM`,
- **доступна** всем потокам `JVM`,
- **хранит** скомпилированный код, а именно структуру для каждого класса:
  - пул констант времени выполнения (`Run-time Constant Pool`),
  - данные о полях и методах класса,
  - код методов и конструкторов,
  - специальные методы `JVM`, в том числе для инициализации классов и интерфейсов.

Хотя `Method Area` является логически частью `Heap`'a, простые реализации могут не собирать мусор с помощью `garbage collector`. `Method Area` может быть фиксированного размера или динамически изменяющаяся (расширяющаяся/сжимающаяся) в зависимости от вычислений.

Если при работе требуется больше памяти, то бросится `OutOfMemoryError`.



#### `Metaspace` - `Method Area` в `JVM HotSpot`

В `JVM HotSpot` с версии `se8` область `Method Area` называется `Metaspace`, ранее область называлась `Permanent Generation`. Для установки минимального и максимального размера области `Metaspace` используются флаги:

- `-XX:MetaspaceSize=256m` - установить началый размер области,
- `-XX:MaxMetaspaceSize=512m` - установить максимальный размер области.

````bash
java -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m  Test
````



### Пул констант времени выполнения (`Run-Time Constant Pool`)

Пул констант времени выполнения - это таблица для констант (`constant_pool`), которая хранится в `class file` ,

- **выделяется** при создании каждого класса/интерфейса из `Method Area`;
- **хранит** различные виды констант, начиная от числовых литералов и заканчивая ссылками на методы и поля, которые должны быть доступны в `Run-Time` для реализации позднего связывания.

Если при создании требуется больше памяти, то бросится `OutOfMemoryError`.



### Стек для нативных методов (`Native Method Stacks`)

> Нативный метод (`Native method`) - метод, который написан не на `java`, а например, на `C`. 

Стек для нативных методов (`Native Method Stacks`) - это приватная область памяти в `RAM` ,  необходимая для работы `native methods`, так как обычный стек для этого не подходит,

- **выделяется** при создании потока `JVM`,
- **доступна** только потоку-создателю, 
- **хранит** данные аналогичные обычному `Stack`.

`Native Method Stacks` может быть фиксированного размера или динамически изменяющийся (может расширяться/сужаться) в зависимости от вычислений. 

Если при вычислениях в потоке требуется больше памяти, то бросится `StackOverflowError`. Если нехватка памяти случилась при расширении или при создании/инициализации `Native Method Stacks`, то бросится `OutOfMemoryError`.

> Интересно #1: Cпецификация `JVM` позволяет не реализовывать `Native Method Stacks` и не поддерживать загрузку `native method`.



### Фрейм (`Frame`)

Фрейм (`Frame`) - это сущность в `JVM`, которая

- **создается** каждый раз при вызове метода,
- **выделяется** из `Stack`'а `JVM`,
- **уничтожается** при завершении метода, либо штатном, либо не штатном (выброс исключения), 
- **доступнен** только потоку-создателю, 
- **служит для**
  - обработки данных и промежуточных результатов,
  - обработки возвращаемого значения из метода,
  - выполнения динамического свазывания,
  - обработки исключений;
- **имеет**
  - собственный массив локальных переменных (`Local Variable Array`),
  - собственный `Operand Stack`,
  - ссылку на `Run-Time Constant Pool` текущего класса,
  - при дебаге спецальную дополнительную информацию.

Размер `Local Variable Array` и `Operand Stack` определяются в `Compile-Time`. Структура данных `Frame` зависит только от реализации `JVM` и память для всех структрур (`Local Variable Array` и `Operand Stack` ) может быть выделена одновременно при вызове метода.

Только один фрейм исполняется в любой точке потока - текущий фрейм (`current frame`), а класс в котором определен метод называется текущим классом (`current class`). Фрейм перестает быть текущим, если его метод вызывает другой метод или метод завершается. Когда новый метод вызывается, то создается новый текущий фрейм, затем управление переходи к новому методу. При возврате метода, текущий фрейм передает обратно результаты в метод вызвавший его. Текущий фрейм удаляется и предыдущий фрейм становится текущим.



### Массив локальных переменных (`Local Variable Array`)

Массив локальных переменных (`Local Variable Array`) - это массив переменных в каждом `Frame`'е,

- **выделяется** при созднии `Frame`'а,
- **доступнен** `Frame`'у-создателю,
- **хранит** следущие типы локальных переменных:
  - `boolean`, 
  - `byte`, 
  - `char`,
  -  `short`,
  -  `int`,
  -  `float`,
  -  `reference`,
  -  `returnAddress`,
  - `long` и `double`  (занимают две локальные переменные).

Длина `Local Variable Array` определяется в `Compile-Time` и хранится вместе с кодом метода в двоичном представлении класса/интерфейса. 

Спецификация `JVM` резервируют для хранения `long` и `double` две последовательные локальные переменные. Однако спецификация не обязывает выравнивать значения по 64-битной схеме, поэтому разработчики могут реализовывать свои способы храенния `long` и `double`.

Все аргументы метода передаются в `Local Variable Array`, в ячейке с индексом `0` хранится ссылка на объект `this`, далее остальные переменные.



### Operand Stacks

Каждый фрейм содержит стек `last-in-first-out` (LIFO), известный как `operand stack`.

Максимальная глубина стека операндов кадра определяется во время компиляции и предоставляется вместе с кодом для метода, связанного с фреймом.

Там, где это ясно по контексту, мы иногда будем называть `operand stack` текущего фрейма просто стеком операндов.

Стек операнда пуст при создании кадра, который его содержит.

`JVM` предоставляет инструкции для загрузки констант или значений из локальных переменных или полей в стек операндов.

Другие инструкции виртуальной машины Java берут операнды из стека операндов, оперируют с ними и помещают результат обратно в стек операндов.

Стек операндов также используется для подготовки параметров, передаваемых в методы, и для получения результатов метода.

Например, инструкция iadd (§iadd) добавляет два значения int вместе.

Требуется, чтобы значения int, которые нужно добавить, были двумя верхними значениями стека операндов, выдвинутых туда предыдущими инструкциями.

Оба значения int извлекаются из стека операндов. Они добавляются, а их сумма возвращается в стек операндов. Подкомпьютеры могут быть вложены в стек операндов, что приводит к значениям, которые могут использоваться охватывающим вычислением.

Каждая запись в стеке операндов может содержать значение любого типа виртуальной машины Java, включая значение типа long или типа double.

Значения из стека операндов должны обрабатываться способами, соответствующими их типам. Например, невозможно выдвинуть два значения типа int и затем обработать их как long или выдвинуть два значения типа float, а затем добавить их с помощью инструкции iadd. Небольшое количество инструкций виртуальной машины Java (инструкции dup (§dup) и swap (§swap)) работают с областями данных времени выполнения в виде необработанных значений без учета их конкретных типов; Эти инструкции определены таким образом, что их нельзя использовать для изменения или разбивки отдельных значений. Эти ограничения на работу со стеком операндов применяются посредством проверки файла класса (§4.10).

В любой момент времени стек операндов имеет связанную глубину, где значение типа long или double добавляет две единицы к глубине, а значение любого другого типа - одну единицу.



### Dynamic Linking

Каждый кадр содержит ссылку на пул констант во время выполнения для типа текущего метода для поддержки динамическое связывание кода метода. Код файла `class` для метода относится к вызываемым методам и переменным, доступ к которым осуществляется через символические ссылки. **символические ссылки?**

Динамическое связывание преобразует эти символьные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимости для разрешения пока еще не определенных символов, и преобразует обращения к переменным в соответствующие смещения в структурах хранения, связанных с расположением этих переменных во время выполнения.

Позднее связывание методов и переменных вносит изменения в другие классы, которые метод использует с меньшей вероятностью нарушить этот код.



### Normal Method Invocation Completion

Вызов метода завершается нормально, если этот вызов не вызывает исключение для выброса, либо непосредственно из виртуальной машины Java, либо в результате выполнения явного оператора `throw`. Если вызов текущего метода завершается нормально, то значение может быть возвращено вызывающему методу. Это происходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которого должен соответствовать типу возвращаемого значения (если оно есть).

Текущий кадр в этом случае используется для восстановления состояния invoker, включая его локальные переменные и стек операндов, с программным счетчиком invoker, соответствующим образом увеличенным, чтобы пропустить инструкцию вызова метода. Затем выполнение обычно продолжается в кадре вызывающего метода с возвращенным значением (если оно есть), помещаемым в стек операндов этого кадра.



### Abrupt Method Invocation Completion

Вызов метода завершается преждевременно, если при выполнении инструкции виртуальной машины Java в методе виртуальная машина Java выдает исключение (§2.10), и это исключение не обрабатывается в методе. Выполнение команды athrow (§athrow) также вызывает явное генерирование исключения и, если текущий метод не обнаруживает исключение, приводит к неожиданному завершению вызова метода. Вызов метода, который завершается внезапно, никогда не возвращает значение своему вызывающему.







## Пример программы!



The Java Virtual Machine expects that nearly all type checking is done prior to run time, typically by a compiler, and does not have to be done by the Java Virtual Machine itself.

The Java Virtual Machine contains explicit support for objects. An object is either a dynamically allocated class instance or an array

A reference to an object is considered to have Java Virtual Machine type `reference`



**Картинка**

![]({{ site.baseurl }}/img/functional-interfaces/1.png)



# Вопросы

**Общее**

1. Какие типы данных существуют в `java`?
2. Сколько примитивынй типов существует и что это за типы?
3. Сколько видов ссылочных типов существует и что это за виды?
4. Массив - это объект? Если - да, то зачем и почему?

**Регистры потока**

1. Что такое регистр поток , как он работает, что хранит?
2. Кто имеет доступ к регистрам потока? Можно ли обращаться из разных потоков?

**Stack**

1. Что такое `Stack` , как он работает, что хранит?
2. Кто имеет доступ к `Stack`? Можно ли обращаться из разных потоков?
3. Размер `Stack` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Stack`?
5. Может ли `Stack` бросить `OutOfMemoryError`?

**Heap**

1. Что такое `heap` , как он работает, что хранит?
2. Кто имеет доступ к `heap`? Можно ли обращаться из разных потоков?
3. Размер `heap` динамически изменяемый?
4. Как задать минимальный и максимальный размер `heap`?
5. Как происходит сборка мусора в `Heap`?

**Method Area**

1. Что такое `Method Area` , как она работает, что хранит?
2. Кто имеет доступ к `Method Area`? Можно ли обращаться из разных потоков?
3. Размер `Method Area` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Method Area`?

**Run-Time Constant Pool**

1. Что такое `Run-Time Constant Pool`, как она работает, что хранит?
2. Кто имеет доступ к `Run-Time Constant Pool`? Можно ли обращаться из разных потоков?
3. Размер ``Run-Time Constant Pool` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Run-Time Constant Pool`?

**Native Method Stacks**

1. Что такое `Native Method Stacks`, как он работает, что хранит?
2. Кто имеет доступ к `Native Method Stacks`? Можно ли обращаться из разных потоков?
3. Размер `Native Method Stacks` динамически изменяемый?
4. Как задать минимальный и максимальный размер `Native Method Stacks`?
5. Может ли `Native Method Stacks` бросить `OutOfMemoryError`?

**Frame**

1. Что такое `Frame`, как он работает, что хранит?
2. Какова структура `Frame`?
3. Когда создается и уничтожается `Frame`?
4. Как переходит управление от `Frame`'а к `Frame`'у? При вызове метода и при возврате значения?
5. Кто имеет доступ к `Frame`? Можно ли обращаться из разных потоков?
6. Как выделяется память для `Frame` и для его структуры?
7. Как задать минимальный и максимальный размер `Frame`?

**Local Variable Array**

1. Что такое `Local Variable Array`, как он работает, что хранит?
2. Как хранятся переменные `long` и `double`?
3. Зачем существует возможность хранения `returnAddress`?
4. Когда создается и уничтожается `Local Variable Array`?
5. Как определяется длина `Local Variable Array`?
6. Что хранится в нулевом индексе `Local Variable Array`?

**Extended**

1. `Stack` и `Heap` расположены оба в `RAM`, правильно? Где доступ быстрее и почему в `Stack` или `Heap`?









Другие вопросы

1. Что такое `statically-typed`?
   - [The Java programming language is statically-typed, which means that all variables must first be declared before they can be used.](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
2. Для чего можно и нельзя использовать `float` and `double` ?
3. Зачем существует класс `BigDecimal`?
4. [Почему "Relying on such default values, however, is generally considered bad programming style"?](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)



# Источники

1. [Primitive Data Types](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
2. [The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html) 
3. [Стек и куча в Java](https://topjava.ru/blog/stack-and-heap-in-java)  



4. [Википедия - Регистр процессора](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0)
5. https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html
6. https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html
7. https://www.baeldung.com/java-stack-heap



## [Скачать приложение]({{ site.baseurl }}/download/01-java/functional-interfaces.zip)